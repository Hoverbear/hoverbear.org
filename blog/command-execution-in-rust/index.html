<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>Command Execution in Rust
        </title>
        <meta name="description" content="A computer scientist working in open source towards a more hopeful future." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg"/>
        <meta property='og:image' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg"/>
        <meta name="twitter:site" content="@a_hoverbear"/>
        <meta name="twitter:creator" content="@a_hoverbear"/>
        
        
            <meta name="twitter:title" content="Command Execution in Rust"/>
            <meta property='og:title' content="Command Execution in Rust"/>
        

        
            <meta property='og:url' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;command-execution-in-rust&#x2F;"/>
        

        
            <meta name="twitter:description" content="One of my projects over the upcoming semester is to explore the Linux boot process and the job of the init (initialization) system. The init system is considered PID 1 and is responsible for a significant portion of userspace functionality. Common init systems on Linux are OpenRC and systemd. One of the key parts of an init system is to spawn new processes, like in command shell.
Executing child processes may be useful to any number of programs, but common applications include:

Shells
Init systems
Launchers
Interfacing with command line applications

"/>
            <meta property='og:description' content="One of my projects over the upcoming semester is to explore the Linux boot process and the job of the init (initialization) system. The init system is considered PID 1 and is responsible for a significant portion of userspace functionality. Common init systems on Linux are OpenRC and systemd. One of the key parts of an init system is to spawn new processes, like in command shell.
Executing child processes may be useful to any number of programs, but common applications include:

Shells
Init systems
Launchers
Interfacing with command line applications

"/>
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Delius&family=Fira+Code&family=Noto+Sans&display=swap" rel="stylesheet">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    

    <body>
        
    <div id="hero-wrapper">
    <figure class="enriched ">
        <figcaption>Photo&nbsp;- <a href="https://unsplash.com/photos/-N0cgDSF_MI">Kobi Li</a></figcaption>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a3aed6e7b2f3210400.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;2851c84fd6c5141000.jpg"
              alt="Photo" />
    </figure>
</div>

    <header>
    <div class="content">
        <h1 id="main-title"><a id="main-link" href="https:&#x2F;&#x2F;hoverbear.org">
            Command Execution in Rust
        </a></h1>

        <nav id="tree"><ul><li>
            <a href="https://hoverbear.org/about/">
                Ana, Hoverbear üêª
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/consulting/">
                Consulting Services
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/blog/">
                Articles
            </a>&nbsp;
        </li></ul><ul></ul><ul></ul>
</nav>


        <div class="metadata">
            <p class="description">
                    A computer scientist working in open source towards a more hopeful future.
                </p>

            <p class="date">
                    Posted on 2014-09-07, around 7 minutes of reading.
                </p>
        </div>
    </div>
</header>

    <main>
        
    <nav id=toc>
        <ol>
            
            <li>
                <a href="https://hoverbear.org/blog/command-execution-in-rust/#using-libc">Using libc</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/command-execution-in-rust/#using-std-io-process">Using std::io::process</a>
                
                <ol>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/command-execution-in-rust/#introducing-command">Introducing Command</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/command-execution-in-rust/#in-and-out">In and Out</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/command-execution-in-rust/#spawning-and-managing-the-children">Spawning and managing the Children</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/command-execution-in-rust/#init-s-perspective">Init&#x27;s Perspective</a>
                    </li>
                    
                </ol>
                
            </li>
            
        </ol>
    </nav>

        <p>One of my projects over the upcoming semester is to explore the Linux boot process and the job of the init (initialization) system. The init system is considered <strong>PID 1</strong> and is responsible for a significant portion of userspace functionality. Common init systems on Linux are OpenRC and systemd. One of the key parts of an init system is to spawn new processes, like in command shell.</p>
<p>Executing child processes may be useful to any number of programs, but common applications include:</p>
<ul>
<li>Shells</li>
<li>Init systems</li>
<li>Launchers</li>
<li>Interfacing with command line applications</li>
</ul>
<span id="continue-reading"></span><h1 id="using-libc">Using libc</h1>
<p>If you are familiar with C/C++, or other languages, you may have used one of the following functions:</p>
<pre><code> int execl(const char *path, const char *arg, ...);
 int execlp(const char *file, const char *arg, ...);
 int execle(const char *path, const char *arg , ..., char * const envp[]);
 int execv(const char *path, char *const argv[]);
 int execvp(const char *file, char *const argv[]);
</code></pre>
<p>Each of these functions provide some variant of process spawning. Most of these are still available in Rust if you so desire. They can be accessed in <a href="http://doc.rust-lang.org/libc/funcs/posix88/unistd/index.html"><code>libc</code></a>. Note these are unsafe C bindings.</p>
<pre><code>pub unsafe fn execv(prog: *const c_char, argv: *mut *const c_char) -&gt; c_int
pub unsafe fn execve(prog: *const c_char, argv: *mut *const c_char, envp: *mut *const c_char) -&gt; c_int
pub unsafe fn execvp(c: *const c_char, argv: *mut *const c_char) -&gt; c_int
</code></pre>
<p>This <code>unsafe</code> access is exactly what it says on the box, unsafe. We'll be forced to use C constructs directly and manipulate raw pointers, this is not an ideal scenario. In order to properly use this code we'd need to construct safe wrappers. But surely there is a better way?</p>
<h1 id="using-std-io-process">Using std::io::process</h1>
<p>The <a href="http://doc.rust-lang.org/std/io/process/index.html"><code>std::io::process</code></a> module provides robust facilities for spawning child processes. In particular <code>Command</code> allows us to build and spawn processes easily.</p>
<h2 id="introducing-command">Introducing <code>Command</code></h2>
<p><code>std::io::process::Command</code>, aliased as <code>std::io::Command</code>, is a type that acts as a process builder. The <a href="http://doc.rust-lang.org/std/io/process/struct.Command.html#method.new"><code>Command::new()</code></a> command sets up several sane defaults for the program for you.</p>
<pre><code>fn new&lt;T: ToCStr&gt;(program: T) -&gt; Command
</code></pre>
<p>The various builder functions allow for customization over the defaults, which are:</p>
<ul>
<li>No arguments to the program</li>
<li>Inherit the current process's environment</li>
<li>Inherit the current process's working directory</li>
<li>A readable pipe for stdin (file descriptor 0)</li>
<li>A writeable pipe for stdout and stderr (file descriptors 1 and 2)</li>
</ul>
<h2 id="in-and-out">In and Out</h2>
<p>In  a simple example, lets collect the output of <code>ps aux</code>:</p>
<pre><code>use std::io::Command;

fn main() {
    // Spawn a process, wait for it to finish, and collect it's output
    let the_output = Command::new(&quot;ps&quot;).arg(&quot;aux&quot;).output()
        .ok().expect(&quot;Failed to execute.&quot;);
    // Encode the resulting data.
    let encoded = String::from_utf8_lossy(the_output.output.as_slice());
    print!(&quot;{}&quot;, encoded);
}
</code></pre>
<p>It should be noted that this is a blocking call, meaning the current task will halt until the completion of the process. This is acceptable for simple calls to the underlying operating system. <code>.output()</code> will handle all the tasks related to piping and spawning for you.</p>
<p>If you're dealing with multiple arguments, you can pass a slice, like so:</p>
<pre><code>let the_output = Command::new(&quot;ps&quot;).args([&quot;a&quot;, &quot;u&quot;, &quot;x&quot;]).output()
    .ok().expect(&quot;Failed to execute.&quot;);
</code></pre>
<h2 id="spawning-and-managing-the-children">Spawning and managing the Children</h2>
<p>Waiting for the command to <strong>completely</strong> return is kind of lame. What would be better some way to keep track of the process and communicate with it.</p>
<pre><code>fn spawn(&amp;self) -&gt; IoResult&lt;Process&gt;
</code></pre>
<p>The <a href="http://doc.rust-lang.org/std/io/process/struct.Process.html"><code>Process</code></a> type returned by <code>.spawn()</code> does just this.</p>
<pre><code>use std::io::Command;

fn main() {
    // Spawn a process. Do not wait for it to return.
    // Process should be mutable if we want to signal it later.
    let mut the_process = Command::new(&quot;curl&quot;)
        .arg(&quot;http://www.hoverbear.org&quot;)
        .spawn().ok().expect(&quot;Failed to execute.&quot;);
    // Do things with `the_process`
}
</code></pre>
<p>We can get the <a href="http://doc.rust-lang.org/std/io/process/struct.Process.html#method.id">PID</a> of the child:</p>
<pre><code>// Get the PID of the process.
println!(&quot;The PID is: {}&quot;, the_process.id());
</code></pre>
<p>Or <a href="http://doc.rust-lang.org/std/io/process/struct.Process.html#method.signal">signal</a> the process:</p>
<pre><code>// Signal the process.
// 0 is interpreted as a poll check.
match the_process.signal(0) {
    Ok(_)  =&gt; println!(&quot;Process still alive!&quot;),
    Err(_) =&gt; println!(&quot;Process dead.&quot;)
}
</code></pre>
<p><em>Note</em>: <code>.signal_exit()</code> and <code>.signal_kill()</code> are also available.</p>
<p><a href="http://doc.rust-lang.org/std/io/process/struct.Process.html#method.wait">Wait</a> for the process before returning, receiving it's status:</p>
<pre><code>// Wait for the process to exit.
match the_process.wait() {
    Ok(status) =&gt; println!(&quot;Finished, status of {}&quot;, status),
    Err(e)     =&gt; println!(&quot;Failed, error: {}&quot;, e)
}
</code></pre>
<p><em>Gotcha</em>: Some processes will not exit until you drain their STDOUT.</p>
<p>Retrieve STDOUT, interacting with it like any <a href="http://doc.rust-lang.org/std/io/trait.Reader.html">Reader</a>:</p>
<pre><code>// Get a Pipestream, which implements the Reader trait.
let the_stdout_stream = the_process.stdout.as_mut()
    .expect(&quot;Couldn't get mutable Pipestream.&quot;);
// Drain it into a &amp;mut [u8].
let the_stdout = the_stdout_stream.read_to_end()
    .expect(&quot;Couldn't read from Pipestream.&quot;);

</code></pre>
<p>Pipe into STDIN, also, <a href="http://doc.rust-lang.org/std/io/process/struct.Process.html#method.wait_with_output">wait for output</a> and exit:</p>
<pre><code>use std::io::Command;

fn main() {
    let mut the_process = Command::new(&quot;grep&quot;).arg(&quot;foo&quot;)
        .spawn().ok().expect(&quot;Failed to execute.&quot;);
    // Get a Pipestream which implements the writer trait.
    // Scope, to ensure the borrow ends.
    let _ = {
        let the_stdin_stream = the_process.stdin.as_mut()
            .expect(&quot;Couldn't get mutable Pipestream.&quot;);
        // Write to it in binary.
        the_stdin_stream.write_int(123456)
            .ok().expect(&quot;Couldn't write to stream.&quot;);
        the_stdin_stream.write(b&quot;Foo this, foo that!&quot;)
            .ok().expect(&quot;Couldn't write to stream.&quot;);
        // Flush the output so it ends.
        the_stdin_stream.flush()
            .ok().expect(&quot;Couldn't flush the stream.&quot;);
    };
    // Wait on output.
    match the_process.wait_with_output() {
        Ok(out)    =&gt; print!(&quot;{}&quot;, out.output.into_ascii()
                          .into_string()),
        Err(error) =&gt; print!(&quot;{}&quot;, error)
    }
}
</code></pre>
<blockquote>
<p>Rust's borrow check ensures that the process cannot be closed until it is safe to.</p>
</blockquote>
<p>Without the scope, the lifetime of the <code>the_stdin_stream</code> would still exist when we try to call <code>the_process.wait_with_output()</code>. If it was the case that this wasn't tracked, it's possible that <code>the_stdin_stream</code> might be used even after the process is closed, something unsafe. We use a scope to limit the lifetime of <code>the_stdin_stream</code>, a function could also accomplish this. <a href="http://doc.rust-lang.org/guide-lifetimes.html">More info on lifetimes.</a></p>
<h2 id="init-s-perspective">Init's Perspective</h2>
<p>An init system concerned about more then just the output of a process. It's concerned about the entire lifetime, which user ID runs it, what kind of ENV is exposed to it, what other processes depend on it, and where its STDOUT and STDERR go. So what would a full call to <code>Command</code> look like for an init system?</p>
<p>Lets say we want to spawn <code>curl</code>, a very long running process, and map it's STDOUT and STDERR to files. We'll also explicitly declare which user and group it should run as, as well as it's CWD and ENV variables.</p>
<p>In it's simplest form:</p>
<pre><code>extern crate native;
extern crate rustrt;

use std::io::{process, Command};
use native::io::file;
use rustrt::rtio;

fn main() {
    // Open a stdout file. Note this is using the native runtime.
    // The native runtime will allow us to retrieve a file descriptor.
    let stdout_file = file::open(&amp;&quot;stdout_log&quot;.to_c_str(),
                                 rtio::Open,
                                 rtio::ReadWrite)
        .ok().expect(&quot;Couldn't open STDOUT file.&quot;);
    // The same with stderr.
    let stderr_file = file::open(&amp;&quot;stderr_log&quot;.to_c_str(),
                                 rtio::Open,
                                 rtio::ReadWrite)
        .ok().expect(&quot;Couldn't open STDERR file.&quot;);
    // Generate the process very explicitly.
    let mut the_process = Command::new(&quot;curl&quot;)
        // Slice of arguments.
        .args([&quot;hoverbear.org&quot;])
        // Set User/Group.
        .uid(1000) // Don't know it? Check that user's $UID
        .gid(1000)
        // Set STDOUT
        .stdout(process::InheritFd(stdout_file.fd()))
        // Set STDERR
        .stderr(process::InheritFd(stderr_file.fd()))
        // Set the CWD.
        .cwd(&amp;Path::new(&quot;/home/hoverbear&quot;))
        // Set ENV variables.
        .env(&quot;IS_EXAMPLE&quot;, &quot;true&quot;)
        // Or remove ENV variables.
        .env_remove(&quot;PRIVATE_VARIABLE&quot;)
        // Spawn
        .spawn().ok().expect(&quot;Failed to execute&quot;);
    // ...
    // Do stuff
    // ...

    // Wait for the process.
    let the_status = the_process.wait()
        .ok().expect(&quot;Couldn't wait for process.&quot;);
    // Output some exit information.
    match the_status {
        process::ExitStatus(x) =&gt; println!(&quot;Exited with status {}&quot;, x),
        process::ExitSignal(x) =&gt; println!(&quot;Exited from signal {}&quot;, x)
    };
}
</code></pre>
<p>An init system often tracks many processes, how could you use the above code in a setting where multiple processes are needed? How could we utilize various constructs to monitor and augment the capabilities of a system?</p>
<p>This is only the humble beginning.</p>

    </main>
    <footer class="post-footer">
    Connect through &nbsp<a href="mailto:operator@hoverbear.org">operator@hoverbear.org</a>,&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
    or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
</footer>
<pre class="artifact"><a id="commit" href="https://github.com/Hoverbear/hoverbear.org/commit/da034546dcea5f4d6d55dd32b6410d8a8e93e7ef
">da034546dcea5f4d6d55dd32b6410d8a8e93e7ef
</a></pre>
    </body>

</html>
