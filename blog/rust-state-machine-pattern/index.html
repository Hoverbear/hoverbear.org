<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>Pretty State Machine Patterns in Rust
        </title>
        <meta name="description" content="A computer scientist working in open source towards a more hopeful future." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;8c1242a9039a024500.jpg">
        <meta name="twitter:site" content="@a_hoverbear">
        <meta name="twitter:creator" content="@a_hoverbear">
        
            <meta name="twitter:title" content="Pretty State Machine Patterns in Rust">
        
        
            <meta name="twitter:description" content="Lately I&#x27;ve been thinking a lot about the patterns and structures which we program with. It&#x27;s really wonderful to start exploring a project and see familiar patterns and styles which you&#x27;ve already used before. It makes it easier to understand the project, and empowers you to start working on the project faster.
Sometimes you&#x27;re working on a new project and realize that you need to do something in the same way as you did in another project. This thing might not be a functionality or a library, it might not be something which you can encode into some clever macro or small crate. Instead, it may be simply a pattern, or a structural concept which addresses a problem nicely.
One interesting pattern that is commonly applied to problems is that of the &#x27;State Machine&#x27;. Let&#x27;s take some time to consider what exactly we mean when we say that, and why they&#x27;re interesting.
">
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Delius&family=Fira+Code&family=Noto+Sans&display=swap" rel="stylesheet">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    

    <body>
        
    <div id="hero-wrapper">
    <figure class="enriched ">
        <figcaption>Photo&nbsp;- Samuel Zeller</figcaption>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;05e6d50518ada3f700.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;8c1242a9039a024500.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;f38b56aae592cd1900.jpg"
              alt="Photo" />
    </figure>
</div>

    <header>
    <div class="content">
        <h1 id="main-title"><a id="main-link" href="https:&#x2F;&#x2F;hoverbear.org">
            Pretty State Machine Patterns in Rust
        </a></h1>

        <nav id="tree"><ul><li>
            <a href="https://hoverbear.org/about/">
                Ana, Hoverbear üêª
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/consulting/">
                Consulting Services
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/blog/">
                Articles
            </a>&nbsp;
        </li></ul><ul></ul><ul></ul>
</nav>


        <div class="metadata">
            <p class="description">
                    A computer scientist working in open source towards a more hopeful future.
                </p>

            <p class="date">
                    Posted on 2016-10-12, around 20 minutes of reading.
                </p>
        </div>
    </div>
</header>

    <main>
        
    <nav id=toc>
        <ol>
            
            <li>
                <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#founding-our-concepts">Founding Our Concepts</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#determining-what-we-want">Determining What We Want</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#exploring-possible-implementation-options">Exploring Possible Implementation Options</a>
                
                <ol>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#a-second-shot-with-enums">A Second Shot with Enums</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#structures-with-transitions">Structures With Transitions</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#generically-sophistication">Generically Sophistication</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#getting-messy-with-the-parents">Getting Messy With the Parents</a>
                    </li>
                    
                </ol>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#worked-examples">Worked Examples</a>
                
                <ol>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#three-state-two-transitions">Three State, Two Transitions</a>
                    </li>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#a-raft-example">A Raft Example</a>
                    </li>
                    
                </ol>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#alternatives-from-feedback">Alternatives From Feedback</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/rust-state-machine-pattern/#closing-thoughts">Closing Thoughts</a>
                
            </li>
            
        </ol>
    </nav>

        <p>Lately I've been thinking a lot about the <em>patterns</em> and <em>structures</em> which we program with. It's really wonderful to start exploring a project and see familiar patterns and styles which you've already used before. It makes it easier to understand the project, and empowers you to start working on the project faster.</p>
<p>Sometimes you're working on a new project and realize that you need to do something in the same way as you did in another project. This <em>thing</em> might not be a functionality or a library, it might not be something which you can encode into some clever macro or small crate. Instead, it may be simply a pattern, or a structural concept which addresses a problem nicely.</p>
<p>One interesting pattern that is commonly applied to problems is that of the 'State Machine'. Let's take some time to consider what exactly we mean when we say that, and why they're interesting.</p>
<span id="continue-reading"></span>
<blockquote>
<p>Throughout this post you can run all examples in <a rel="noopener" target="_blank" href="https://play.rust-lang.org/">the playground</a>, I typically use 'Nightly' out of habit.</p>
</blockquote>
<h2 id="founding-our-concepts">Founding Our Concepts</h2>
<p>There are a <strong>lot</strong> of resources and topical articles about state machines out there on the internet. Even more so, there are a lot of <strong>implementations</strong> of state machines.</p>
<p>Just to get to this web page you used one. You can model TCP as a state machine. You can model HTTP requests with one too. You can model any <em>regular</em> language, such as a regex, as a state machine. They're everywhere, hiding inside things we use every day.</p>
<p>So, a State Machine is any <strong>'machine'</strong> which has a set of <strong>'states'</strong> and <strong>'transitions'</strong> defined between them.</p>
<p>When we talk about a machine we're referring to the abstract concept of something which <em>does something</em>. For example, your 'Hello World!' function is a machine. It is started and eventually outputs what we expect it to. Some model which you use to interact with your database is just the same. We'll regard our most basic machine simply as a <code>struct</code> that can be created and destroyed.</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Machine</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
  </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> my_machine </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> Machine</span><span style="color:#ccc9c2cc;">; </span><span style="font-style:italic;color:#5c6773;">// Create.
  // `my_machine` is destroyed when it falls out of scope below.
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>States are a way to reason about <em>where</em> a machine is in its process. For example, we can think about a bottle filling machine as an example. The machine is in a 'waiting' state when it is waiting for a new bottle. Once it detects a bottle it moves to the 'filling' state. Upon detecting the bottle is filled it enters the 'done' state. After the bottle is left the machine we return to the 'waiting' state.</p>
<p>A key takeaway here is that none of the states have any information relevant for the other states. The 'filling' state doesn't care how long the 'waiting' state waited. The 'done' state doesn't care about what rate the bottle was filled at. Each state has <em>discrete responsibilities and concerns</em>. The natural way to consider these <em>variants</em> is as an <code>enum</code>.</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">enum </span><span style="color:#73d0ff;">BottleFillerState </span><span style="color:#ccc9c2;">{
  Waiting { waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration }</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">  Filling { rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize </span><span style="color:#ccc9c2;">}</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">  Done</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">}

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">BottleFiller </span><span style="color:#ccc9c2;">{
  state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> BottleFillerState,
}
</span></code></pre>
<p>Using an <code>enum</code> in this way means all the states are mutually exclusive, you can only be in one at a time. Rust's 'fat enums' allow us to have each of these states to carry data with them as well. As far as our current definition is concerned, everything is totally okay.</p>
<p>But there is a bit of a problem here. When we described our bottle filling machine above we described three transitions: <code>Waiting -&gt; Filling</code>, <code>Filling -&gt; Done</code>, and <code>Done -&gt; Waiting</code>. We never described <code>Waiting -&gt; Done</code> or <code>Done -&gt; Filling</code>, those don't make sense!</p>
<p>This brings us to the idea of transitions. One of the nicest things about a true state machine is we never have to worry about our bottle machine going from <code>Done -&gt; Filling</code>, for example. The state machine pattern should <strong>enforce</strong> that this can never happen. Ideally this would be done before we even start running our machine, at compile time.</p>
<p>Let's look again at the transitions we described for our bottle filler in a diagram:</p>
<pre style="background-color:#212733;">
<code><span style="color:#ccc9c2;">  +++++++++++   +++++++++++   ++++++++
  |         |   |         |   |      |
  | Waiting +--&gt;+ Filling +--&gt;+ Done |
  |         |   |         |   |      |
  ++++-++++-+   +++++++++++   +--+++++
       ^                         |
       +++++++++++++++++++++++++-+
</span></code></pre>
<p>As we can see here there are a finite number of states, and a finite number of transitions between these states. Now, it is possible to have a valid transition between each state and every other state, but in most cases this is not true.</p>
<p>This means moving between a state such as 'Waiting' to a state such as 'Filling' should have defined semantics. In our example this can be defined as &quot;There is a bottle in place.&quot; In the case of a TCP stream it might be &quot;We have received a FIN packet&quot; which means we need to finish closing out the stream.</p>
<h2 id="determining-what-we-want">Determining What We Want</h2>
<p>Now that we know what a state machine is, how do we represent them in Rust? First, let's think about what we <strong>want</strong> from some pattern.</p>
<p>Ideally, we'd like to see the following characteristics:</p>
<ul>
<li>Can only be in one state at a time.</li>
<li>Each state should able have its own associated values if required.</li>
<li>Transitioning between states should have well defined semantics.</li>
<li>It should be possible to have some level of shared state.</li>
<li>Only explicitly defined transitions should be permitted.</li>
<li>Changing from one state to another should <strong>consume</strong> the state so it can no longer be used.</li>
<li>We shouldn't need to allocate memory for <strong>all</strong> states. No more than largest sized state certainly</li>
<li>Any error messages should be easy to understand.</li>
<li>We shouldn't need to resort to heap allocations to do this. Everything should be possible on the stack.</li>
<li>The type system should be harnessed to our greatest ability.</li>
<li>As many errors as possible should be at <strong>compile-time</strong>.</li>
</ul>
<p>So if we could have a design pattern which allowed for all these things it'd be truly fantastic. Having a pattern which allowed for most would be pretty good too.</p>
<h2 id="exploring-possible-implementation-options">Exploring Possible Implementation Options</h2>
<p>With a type system as powerful and flexible as Rusts we should be able to represent this. The truth is: there are a number of ways to try, each has valuable characteristics, and each teaches us lessons.</p>
<h3 id="a-second-shot-with-enums">A Second Shot with Enums</h3>
<p>As we saw above the most natural way to attempt this is an <code>enum</code>, but we noted already that you can't control which transitions are actually permitted in this case. So can we just wrap it? We sure can! Let's take a look:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">enum </span><span style="color:#73d0ff;">State </span><span style="color:#ccc9c2;">{
    Waiting { waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration }</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">    Filling { rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize </span><span style="color:#ccc9c2;">}</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">    Done
}

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">StateMachine </span><span style="color:#ccc9c2;">{ state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> State }

</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">StateMachine </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">() </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        StateMachine {
            state</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">State</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Waiting { waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2;">) }
        }
    }
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">to_filling</span><span style="color:#ccc9c2;">(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffa759;">mut </span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) {
        </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state </span><span style="color:#f29e74;">= </span><span style="color:#ffa759;">match </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state {
            </span><span style="font-style:italic;color:#5c6773;">// Only Waiting -&gt; Filling is valid.
            </span><span style="color:#ccc9c2;">State</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Waiting { </span><span style="color:#f29e74;">.. </span><span style="color:#ccc9c2;">} </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">State</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Filling { rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">1 </span><span style="color:#ccc9c2;">}</span><span style="color:#ccc9c2cc;">,
            </span><span style="font-style:italic;color:#5c6773;">// The rest should fail.
            </span><span style="color:#f29e74;">_ =&gt; </span><span style="color:#f28779;">panic!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Invalid state tranistion!&quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
    </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span style="color:#ccc9c2;">}

</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> state_machine </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">StateMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">    state_machine</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_filling</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>At first glance it seems okay. But notice some problems?</p>
<ul>
<li>Invalid transition errors happen at runtime, which is awful!</li>
<li>This only prevents invalid transitions <em>outside</em> of the module, since the private fields can be manipulated freely inside the module. For example, <code>state_machine.state = State::Done</code> is perfectly valid inside the module.</li>
<li>Every function we implement that works with the state has to include a match statement!</li>
</ul>
<p>However this does have some good characteristics:</p>
<ul>
<li>The memory required to represent the state machine is only the size of the largest state. This is because a fat enum is only as big as its biggest variant.</li>
<li>Everything happens on the stack.</li>
<li>Transitioning between states has well defined semantics... It either works or it crashes!</li>
</ul>
<p>Now you might be thinking &quot;Hoverbear you could totally wrap the <code>to_filling()</code> output with a <code>Result&lt;T,E&gt;</code> or have an <code>InvalidState</code> variant!&quot; But let's face it: That doesn't make things that much better, if at all. Even if we get rid of the runtime failures we still have to deal with a lot of clumsiness with the match statements and our errors would still only be found at runtime! Ugh! We can do better, I promise.</p>
<p>So let's keep looking!</p>
<h3 id="structures-with-transitions">Structures With Transitions</h3>
<p>So what if we just used a set of structs? We could have them all implement traits which all states should share. We could use special functions that transitioned the type into the new type! How would it look?</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// This is some functionality shared by all of the states.
</span><span style="color:#ffa759;">trait </span><span style="color:#73d0ff;">SharedFunctionality </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_shared_value</span><span style="color:#ccc9c2;">(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Waiting </span><span style="color:#ccc9c2;">{
    waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration,
    </span><span style="font-style:italic;color:#5c6773;">// Value shared by all states.
    </span><span style="color:#ccc9c2;">shared_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
}
</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">Waiting </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">() </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        Waiting {
            waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            shared_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
    </span><span style="font-style:italic;color:#5c6773;">// Consumes the value!
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">to_filling</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt;</span><span style="color:#ccc9c2;"> Filling {
        Filling {
            rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">1</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            shared_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}
</span><span style="color:#ffa759;">impl </span><span style="color:#ccc9c2;">SharedFunctionality </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Waiting </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_shared_value</span><span style="color:#ccc9c2;">(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">usize </span><span style="color:#ccc9c2;">{
        </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">shared_value
    }
}

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Filling </span><span style="color:#ccc9c2;">{
    rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
    </span><span style="font-style:italic;color:#5c6773;">// Value shared by all states.
    </span><span style="color:#ccc9c2;">shared_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
}
</span><span style="color:#ffa759;">impl </span><span style="color:#ccc9c2;">SharedFunctionality </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Filling </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">get_shared_value</span><span style="color:#ccc9c2;">(</span><span style="color:#f29e74;">&amp;</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">usize </span><span style="color:#ccc9c2;">{
        </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">shared_value
    }
}

</span><span style="font-style:italic;color:#5c6773;">// ...

</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_waiting_state </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Waiting</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_filling_state </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> in_waiting_state</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_filling</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>Gosh that's a buncha code! So the idea here was that all states have some common shared values along with their own specialized values. As you can see from the <code>to_filling()</code> function we can consume a given 'Waiting' state and transition it into a 'Filling' state. Let's do a little rundown:</p>
<ul>
<li>Transition errors are caught at compile time! For example you can't even create a <code>Filling</code> state accidentally without first starting with a <code>Waiting</code> state. (You could on purpose, but this is beside the matter.)</li>
<li>Transition enforcement happens everywhere.</li>
<li>When a transition between states is made the old value is <strong>consumed</strong> instead of just modified. We could have done this with the enum example above as well though.</li>
<li>We don't have to <code>match</code> all the time.</li>
<li>Memory consumption is still lean, at any given time the size is that of the state.</li>
</ul>
<p>There are some downsides though:</p>
<ul>
<li>There is a bunch of code repetition. You have to implement the same functions and traits for multiple structures.</li>
<li>It's not always clear what values are shared between all states and just one. Updating code later could be a pain due to this.</li>
<li>Since the size of the state is variable we end up needing to wrap this in an <code>enum</code> as above for it to be usable where the state machine is simply one component of a more complex system. Here's what this could look like:</li>
</ul>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">enum </span><span style="color:#73d0ff;">State </span><span style="color:#ccc9c2;">{
    Waiting(Waiting)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">    Filling(Filling)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">    Done(Done)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">}

</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_waiting_state </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">State</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Waiting(Waiting</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new())</span><span style="color:#ccc9c2cc;">;
    </span><span style="font-style:italic;color:#5c6773;">// This doesn&#39;t work since the `Waiting` struct is wrapped! We need to `match` to get it out.
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_filling_state </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">State</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Filling(in_waiting_state</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">to_filling</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>As you can see, this isn't very ergonomic. We're getting closer to what we want though. The idea of moving between distinct types seems to be a good way forward! Before we go try something entirely different though, let's talk about a simple way to change our example that could enlighten further thinking.</p>
<p>The Rust standard library defines two highly related traits: <a rel="noopener" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a rel="noopener" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> that are extremely useful and worth checking out. An important thing to note is that implementing one of these automatically implements the other. In general implementing <code>From</code> is preferable as it's a bit more flexible. We can implement them very easily for our above example like so:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// ...
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;Waiting&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Filling </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Waiting) </span><span style="color:#ccc9c2cc;">-&gt;</span><span style="color:#ccc9c2;"> Filling {
        Filling {
            rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">1</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            shared_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">shared_value</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}
</span><span style="font-style:italic;color:#5c6773;">// ...
</span></code></pre>
<p>Not only does this give us a common function for transitioning, but it also is nice to read about in the source code! This reduces mental burden on us and makes it easier for readers to comprehend. <em>Instead of implementing custom functions we're just using a pattern already existing.</em> Building our pattern on top of already existing patterns is a great way forward.</p>
<p>So this is cool, but how do we deal with all this nasty code repetition and the repeating <code>shared_value</code> stuff? Let's explore a bit more!</p>
<h3 id="generically-sophistication">Generically Sophistication</h3>
<p>In this adventure we'll combine lessons and ideas from the first two, along with a few new ideas, to get something more satisfying. The core of this is to harness the power of generics. Let's take a look at a fairly bare structure representing this:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">BottleFillingMachine</span><span style="color:#ccc9c2;">&lt;S&gt; {
    shared_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
    state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> S
}

</span><span style="font-style:italic;color:#5c6773;">// The following states can be the &#39;S&#39; in StateMachine&lt;S&gt;

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Waiting </span><span style="color:#ccc9c2;">{
    waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration,
}

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Filling </span><span style="color:#ccc9c2;">{
    rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
}

</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Done</span><span style="color:#ccc9c2cc;">;
</span></code></pre>
<p>So here we're actually building the state into the type signature of the <code>BottleFillingMachine</code> itself. A state machine in the 'Filling' state is <code>BottleFillingMachine&lt;Filling&gt;</code> which is just <strong>awesome</strong> since it means when we see it as part of an error message or something we know immediately what state the machine is in.</p>
<p>From there we can go ahead and implement <code>From&lt;T&gt;</code> for some of these specific generic variants like so:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;BottleFillingMachine&lt;Waiting&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">BottleFillingMachine</span><span style="color:#ccc9c2;">&lt;Filling&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">BottleFillingMachine&lt;Waiting&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">BottleFillingMachine&lt;Filling&gt; {
        BottleFillingMachine {
            shared_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">shared_value</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Filling {
                rate</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">1</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">}
        }
    }
}

</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;BottleFillingMachine&lt;Filling&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">BottleFillingMachine</span><span style="color:#ccc9c2;">&lt;Done&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">BottleFillingMachine&lt;Filling&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">BottleFillingMachine&lt;Done&gt; {
        BottleFillingMachine {
            shared_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">shared_value</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Done</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}
</span></code></pre>
<p>Defining a starting state for the machine looks like this:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">BottleFillingMachine</span><span style="color:#ccc9c2;">&lt;Waiting&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">shared_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        BottleFillingMachine {
            shared_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> shared_value</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Waiting {
                waiting_time</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">time</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Duration</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">}
        }
    }
}
</span></code></pre>
<p>So how does it look to change between two states? Like this:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_waiting </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">BottleFillingMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Waiting&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_filling </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">BottleFillingMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Filling&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(in_waiting)</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>Alternatively if you're doing this inside of a function whose type signature restricts the possible outputs it might look like this:</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">transition_the_states</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">BottleFillingMachine&lt;Waiting&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">BottleFillingMachine&lt;Filling&gt; {
    val</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">() </span><span style="font-style:italic;color:#5c6773;">// Nice right?
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>What do the <strong>compile time</strong> error messages look like?</p>
<pre style="background-color:#212733;">
<code><span style="color:#ccc9c2;">error[E0277]: the trait bound `BottleFillingMachine&lt;Done&gt;: std::convert::From&lt;BottleFillingMachine&lt;Waiting&gt;&gt;` is not satisfied
  --&gt; &lt;anon&gt;:50:22
   |
50 |     let in_filling = BottleFillingMachine::&lt;Done&gt;::from(in_waiting);
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = help: the following implementations were found:
   = help:   &lt;BottleFillingMachine&lt;Filling&gt; as std::convert::From&lt;BottleFillingMachine&lt;Waiting&gt;&gt;&gt;
   = help:   &lt;BottleFillingMachine&lt;Done&gt; as std::convert::From&lt;BottleFillingMachine&lt;Filling&gt;&gt;&gt;
   = note: required by `std::convert::From::from`
</span></code></pre>
<p>It's pretty clear what's wrong from that. The error message even hints to us some valid transitions!</p>
<p>So what does this scheme give us?</p>
<ul>
<li>Transitions are ensured to be valid at compile time.</li>
<li>The error messages about invalid transitions are very understandable and even list valid options.</li>
<li>We have a 'parent' structure which can have traits and values associated with it that aren't repeated.</li>
<li>Once a transition is made the old state no longer exists, it is consumed. Indeed, the entire structure is consumed so if there are side effects of the transition on the parent (for example altering the average waiting time) we can't access stale values.</li>
<li>Memory consumption is lean and everything is on the stack.</li>
</ul>
<p>There are some downsides still:</p>
<ul>
<li>Our <code>From&lt;T&gt;</code> implementations suffer from a fair bit of &quot;type noise&quot;. This is a highly minor concern though.</li>
<li>Each <code>BottleFillingMachine&lt;S&gt;</code> has a different size, with our previous example, so we'll need to use an enum. Because of our structure though we can do this in a way that doesn't completely suck.</li>
</ul>
<blockquote>
<p>You can play with this example <a rel="noopener" target="_blank" href="https://is.gd/CyuJlH"><strong>here</strong></a></p>
</blockquote>
<h3 id="getting-messy-with-the-parents">Getting Messy With the Parents</h3>
<p>So how can we have some parent structure hold our state machine without it being a gigantic pain to interact with? Well, this circles us back around to the <code>enum</code> idea we had at first.</p>
<p>If you recall the primary problem with the <code>enum</code> example above was that we had to deal with no ability to enforce transitions, and the only errors we got were at runtime when we did try.</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">enum </span><span style="color:#73d0ff;">BottleFillingMachineWrapper </span><span style="color:#ccc9c2;">{
    Waiting(BottleFillingMachine&lt;Waiting&gt;)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">    Filling(BottleFillingMachine&lt;Filling&gt;)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">    Done(BottleFillingMachine&lt;Done&gt;)</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">}
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Factory </span><span style="color:#ccc9c2;">{
    bottle_filling_machine</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> BottleFillingMachineWrapper,
}
</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">Factory </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">() </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        Factory {
            bottle_filling_machine</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Waiting(BottleFillingMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2;">))</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}
</span></code></pre>
<p>At this point your first reaction is likely &quot;Gosh, Hoverbear, look at that awful and long type signature!&quot; You're quite right! Frankly it's rather long, but I picked long, explanatory type names! You'll be able to use all your favorite arcane abbreviations and type aliases in your own code. Have at!</p>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">BottleFillingMachineWrapper </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">step</span><span style="color:#ccc9c2;">(</span><span style="color:#ffa759;">mut </span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        </span><span style="color:#ffa759;">match </span><span style="font-style:italic;color:#5ccfe6;">self </span><span style="color:#ccc9c2;">{
            BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Waiting(val) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Filling(val</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Filling(val) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Done(val</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Done(val) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">BottleFillingMachineWrapper</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">Waiting(val</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}

</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let mut</span><span style="color:#ccc9c2;"> the_factory </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Factory</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">    the_factory</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">bottle_filling_machine </span><span style="color:#f29e74;">=</span><span style="color:#ccc9c2;"> the_factory</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">bottle_filling_machine</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">step</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></code></pre>
<p>Again you may notice that this works by <strong>consumption</strong> not mutation. Using <code>match</code> the way we are above <em>moves</em> <code>val</code> so that it can be used with <code>.into()</code> which we've already determined should consume the state. If you'd really like to use mutation you can consider having your states <code>#[derive(Clone)]</code> or even <code>Copy</code>, but that's your call.</p>
<p>Despite this being a bit less ergonomic and pleasant to work with than we might want we still get strongly enforced state transitions and all the guarantees that come with them.</p>
<p>One thing you will notice is this scheme <strong>does</strong> force you to handle all potential states when manipulating the machine, and that makes sense. You are reaching into a structure with a state machine and manipulating it, you need to have defined actions for each state that it is in.</p>
<p>Or you can just <code>panic!()</code> if that's what you really want. But if you just wanted to <code>panic!()</code> then why didn't you just use the first attempt?</p>
<blockquote>
<p>You can see a fully worked example of this Factory example <a rel="noopener" target="_blank" href="https://is.gd/s03IaQ"><strong>here</strong></a></p>
</blockquote>
<h2 id="worked-examples">Worked Examples</h2>
<p>This is the kind of thing it's always nice to have some examples for. So below I've put together a couple worked examples with comments for you to explore.</p>
<h3 id="three-state-two-transitions">Three State, Two Transitions</h3>
<p>This example is very similar to the Bottle Filling Machine above, but instead it <strong>actually</strong> does work, albeit trivial work. It takes a string and returns the number of words in it.</p>
<blockquote>
<p><a rel="noopener" target="_blank" href="https://is.gd/4ITDyV">Playground link</a></p>
</blockquote>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="font-style:italic;color:#5c6773;">// The `&lt;StateA&gt;` is implied here. We don&#39;t need to add type annotations!
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_state_a </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">StateMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="color:#bae67e;">&quot;Blah blah blah&quot;</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// This is okay here. But later once we&#39;ve changed state it won&#39;t work anymore.
</span><span style="color:#ccc9c2;">    in_state_a</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">some_unrelated_value</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Starting Value: </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> in_state_a</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">start_value)</span><span style="color:#ccc9c2cc;">;


    </span><span style="font-style:italic;color:#5c6773;">// Transition to the new state. This consumes the old state.
    // Here we need type annotations (since not all StateMachines are linear in their state).
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_state_b </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">StateMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;StateB&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(in_state_a)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// This doesn&#39;t work! The value is moved when we transition!
    // in_state_a.some_unrelated_value;
    // Instead, we can use the existing value.
</span><span style="color:#ccc9c2;">    in_state_b</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">some_unrelated_value</span><span style="color:#ccc9c2cc;">;

    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Interm Value: </span><span style="color:#ffcc66;">{:?}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> in_state_b</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">interm_value)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// And our final state.
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> in_state_c </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">StateMachine</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;StateC&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(in_state_b)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// This doesn&#39;t work either! The state doesn&#39;t even contain this value.
    // in_state_c.state.start_value;

    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Final state: </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> in_state_c</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">final_value)</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}

</span><span style="font-style:italic;color:#5c6773;">// Here is our pretty state machine.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">StateMachine</span><span style="color:#ccc9c2;">&lt;S&gt; {
    some_unrelated_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
    state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> S,
}

</span><span style="font-style:italic;color:#5c6773;">// It starts, predictably, in `StateA`
</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">StateMachine</span><span style="color:#ccc9c2;">&lt;StateA&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> String) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        StateMachine {
            some_unrelated_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">StateA</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(val)
        }
    }
}

</span><span style="font-style:italic;color:#5c6773;">// State A starts the machine with a string.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">StateA </span><span style="color:#ccc9c2;">{
    start_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> String,
}
</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">StateA </span><span style="color:#ccc9c2;">{
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">start_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> String) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        StateA {
            start_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> start_value</span><span style="color:#ccc9c2cc;">,
        </span><span style="color:#ccc9c2;">}
    }
}

</span><span style="font-style:italic;color:#5c6773;">// State B goes and breaks up that String into words.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">StateB </span><span style="color:#ccc9c2;">{
    interm_value</span><span style="color:#ccc9c2cc;">: </span><span style="font-style:italic;color:#5ccfe6;">Vec</span><span style="color:#ccc9c2;">&lt;</span><span style="font-style:italic;color:#5ccfe6;">String</span><span style="color:#ccc9c2;">&gt;,
}
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;StateMachine&lt;StateA&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">StateMachine</span><span style="color:#ccc9c2;">&lt;StateB&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">StateMachine&lt;StateA&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">StateMachine&lt;StateB&gt; {
        StateMachine {
            some_unrelated_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">some_unrelated_value</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> StateB {
                interm_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">start_value</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">split</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot; &quot;</span><span style="color:#ccc9c2;">)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">map</span><span style="color:#ccc9c2;">(|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">into</span><span style="color:#ccc9c2;">())</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">collect</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">}
        }
    }
}

</span><span style="font-style:italic;color:#5c6773;">// Finally, StateC gives us the length of the vector, or the word count.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">StateC </span><span style="color:#ccc9c2;">{
    final_value</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ffa759;">usize</span><span style="color:#ccc9c2;">,
}
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;StateMachine&lt;StateB&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">StateMachine</span><span style="color:#ccc9c2;">&lt;StateC&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">StateMachine&lt;StateB&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">StateMachine&lt;StateC&gt; {
        StateMachine {
            some_unrelated_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">some_unrelated_value</span><span style="color:#ccc9c2cc;">,
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> StateC {
                final_value</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> val</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">state</span><span style="color:#f29e74;">.</span><span style="color:#ccc9c2;">interm_value</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">len</span><span style="color:#ccc9c2;">()</span><span style="color:#ccc9c2cc;">,
            </span><span style="color:#ccc9c2;">}
        }
    }
}
</span></code></pre><h3 id="a-raft-example">A Raft Example</h3>
<p>If you've followed my posts for awhile you may know I rather enjoy thinking about Raft. Raft, and a discussion with <a rel="noopener" target="_blank" href="https://twitter.com/Argorak"><strong>@argorak</strong></a> were the primary motivators behind all of this research.</p>
<p>Raft is a bit more complex than the above examples as it does not just have linear states where <code>A-&gt;B-&gt;C</code>. Here is the transition diagram:</p>
<pre style="background-color:#212733;">
<code><span style="color:#ccc9c2;">++++++++++-+    ++++++++++--+    +++++++--+
|          ++++-&gt;           |    |        |
| Follower |    | Candidate ++++-&gt; Leader |
|          &lt;+++-+           |    |        |
+++++++--^-+    ++++++++++--+    +-++++++++
         |                         |
         +++++++++++++++++++++++++-+
</span></code></pre>
<blockquote>
<p><a rel="noopener" target="_blank" href="https://is.gd/HDZeGR">Playground link</a></p>
</blockquote>
<pre style="background-color:#212733;">
<code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5c6773;">// You can play around in this function.
</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> is_follower </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Raft</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">new(</span><span style="font-style:italic;color:#5c6773;">/* ... */</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">;
    </span><span style="font-style:italic;color:#5c6773;">// Raft typically comes in groups of 3, 5, or 7. Just 1 for us. :)

    // Simulate this node timing out first.
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> is_candidate </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Raft</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Candidate&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(is_follower)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// It wins! How unexpected.
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> is_leader </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Raft</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Leader&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(is_candidate)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// Then it fails and rejoins later, becoming a Follower again.
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> is_follower_again </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Raft</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Follower&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(is_leader)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// And goes up for election...
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> is_candidate_again </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Raft</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Candidate&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(is_follower_again)</span><span style="color:#ccc9c2cc;">;

    </span><span style="font-style:italic;color:#5c6773;">// But this time it fails!
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> is_follower_another_time </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Raft</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">&lt;Follower&gt;</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">from(is_candidate_again)</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}


</span><span style="font-style:italic;color:#5c6773;">// This is our state machine.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Raft</span><span style="color:#ccc9c2;">&lt;S&gt; {
    </span><span style="font-style:italic;color:#5c6773;">// ... Shared Values
    </span><span style="color:#ccc9c2;">state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> S
}

</span><span style="font-style:italic;color:#5c6773;">// The three cluster states a Raft node can be in

// If the node is the Leader of the cluster services requests and replicates its state.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Leader </span><span style="color:#ccc9c2;">{
    </span><span style="font-style:italic;color:#5c6773;">// ... Specific State Values
</span><span style="color:#ccc9c2;">}

</span><span style="font-style:italic;color:#5c6773;">// If it is a Candidate it is attempting to become a leader due to timeout or initialization.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Candidate </span><span style="color:#ccc9c2;">{
    </span><span style="font-style:italic;color:#5c6773;">// ... Specific State Values
</span><span style="color:#ccc9c2;">}

</span><span style="font-style:italic;color:#5c6773;">// Otherwise the node is a follower and is replicating state it receives.
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Follower </span><span style="color:#ccc9c2;">{
    </span><span style="font-style:italic;color:#5c6773;">// ... Specific State Values
</span><span style="color:#ccc9c2;">}

</span><span style="font-style:italic;color:#5c6773;">// Raft starts in the Follower state
</span><span style="color:#ffa759;">impl </span><span style="color:#73d0ff;">Raft</span><span style="color:#ccc9c2;">&lt;Follower&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">new</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5c6773;">/* ... */</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ffa759;">Self </span><span style="color:#ccc9c2;">{
        </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span style="color:#ccc9c2;">        Raft {
            </span><span style="font-style:italic;color:#5c6773;">// ...
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Follower { </span><span style="font-style:italic;color:#5c6773;">/* ... */ </span><span style="color:#ccc9c2;">}
        }
    }
}

</span><span style="font-style:italic;color:#5c6773;">// The following are the defined transitions between states.

// When a follower timeout triggers it begins to campaign
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;Raft&lt;Follower&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Raft</span><span style="color:#ccc9c2;">&lt;Candidate&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Raft&lt;Follower&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Raft&lt;Candidate&gt; {
        </span><span style="font-style:italic;color:#5c6773;">// ... Logic prior to transition
</span><span style="color:#ccc9c2;">        Raft {
            </span><span style="font-style:italic;color:#5c6773;">// ... attr: val.attr
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Candidate { </span><span style="font-style:italic;color:#5c6773;">/* ... */ </span><span style="color:#ccc9c2;">}
        }
    }
}

</span><span style="font-style:italic;color:#5c6773;">// If it doesn&#39;t receive a majority of votes it loses and becomes a follower again.
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;Raft&lt;Candidate&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Raft</span><span style="color:#ccc9c2;">&lt;Follower&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Raft&lt;Candidate&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Raft&lt;Follower&gt; {
        </span><span style="font-style:italic;color:#5c6773;">// ... Logic prior to transition
</span><span style="color:#ccc9c2;">        Raft {
            </span><span style="font-style:italic;color:#5c6773;">// ... attr: val.attr
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Follower { </span><span style="font-style:italic;color:#5c6773;">/* ... */ </span><span style="color:#ccc9c2;">}
        }
    }
}

</span><span style="font-style:italic;color:#5c6773;">// If it wins it becomes the leader.
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;Raft&lt;Candidate&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Raft</span><span style="color:#ccc9c2;">&lt;Leader&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Raft&lt;Candidate&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Raft&lt;Leader&gt; {
        </span><span style="font-style:italic;color:#5c6773;">// ... Logic prior to transition
</span><span style="color:#ccc9c2;">        Raft {
            </span><span style="font-style:italic;color:#5c6773;">// ... attr: val.attr
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Leader { </span><span style="font-style:italic;color:#5c6773;">/* ... */ </span><span style="color:#ccc9c2;">}
        }
    }
}

</span><span style="font-style:italic;color:#5c6773;">// If the leader becomes disconnected it may rejoin to discover it is no longer leader
</span><span style="color:#ffa759;">impl </span><span style="font-style:italic;color:#5ccfe6;">From</span><span style="color:#ccc9c2;">&lt;Raft&lt;Leader&gt;&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Raft</span><span style="color:#ccc9c2;">&lt;Follower&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">from</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">val</span><span style="color:#ccc9c2cc;">: </span><span style="color:#ccc9c2;">Raft&lt;Leader&gt;) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Raft&lt;Follower&gt; {
        </span><span style="font-style:italic;color:#5c6773;">// ... Logic prior to transition
</span><span style="color:#ccc9c2;">        Raft {
            </span><span style="font-style:italic;color:#5c6773;">// ... attr: val.attr
</span><span style="color:#ccc9c2;">            state</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> Follower { </span><span style="font-style:italic;color:#5c6773;">/* ... */ </span><span style="color:#ccc9c2;">}
        }
    }
}
</span></code></pre><h2 id="alternatives-from-feedback">Alternatives From Feedback</h2>
<p>I saw an interesting comment by <a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/57ccds/pretty_state_machine_patterns_in_rust/d8rhwq4">I-impv on Reddit</a> showing off <a rel="noopener" target="_blank" href="https://play.rust-lang.org/?gist=ee3e4df093c136ced7b394dc7ffb78e1&amp;version=stable&amp;backtrace=0">this approach based on our examples above</a>. Here's what they had to say about it:</p>
<blockquote>
<p>I like the way you did it. I am working on a fairly complex FSM myself currently and did it slightly different.</p>
<p>Some things I did different:</p>
<ul>
<li>I also modeled the input for the state machine. That way you can model your transitions as a match over (State, Event) every invalid combination is handled by the 'default' pattern</li>
<li>Instead of using panic for invalid transitions I used a Failure state, So every invalid combination transitions to that Failure state</li>
</ul>
</blockquote>
<p>I really like the idea of modeling the input in the transitions!</p>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>Rust lets us represent State Machines in a fairly good way. In an ideal situation we'd be able to make <code>enum</code>s with restricted transitions between variants, but that's not the case. Instead, we can harness the power of generics and the ownership system to create something expressive, safe, and understandable.</p>
<p>If you have any feedback or suggestions on this article I'd suggest checking out the footer of this page for contact details. I also hang out on Mozilla's IRC as Hoverbear.</p>

    </main>
    <footer class="post-footer">
    Connect through &nbsp<a href="mailto:operator@hoverbear.org">operator@hoverbear.org</a>,&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
    or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
</footer>
<pre class="artifact"><a id="commit" href="https://github.com/Hoverbear/hoverbear.org/commit/c9e3ae5635b708181d9eb9f551b01a11fb96812a
">c9e3ae5635b708181d9eb9f551b01a11fb96812a
</a></pre>
    </body>

</html>
