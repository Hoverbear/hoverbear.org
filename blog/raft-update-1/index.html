<!DOCTYPE html>
<html>
<head>
    <!-- Fun compatability things -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge"> <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">

    <!-- Information about this site -->
    <title>
        Raft Experiences and Repo Made Public!
    </title>
    <meta name="description"
        content="A computer scientist working in open source towards a more hopeful future." />

    <!-- Various Twitter related content. -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg" />
    <meta property='og:image' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg" />
    <meta name="twitter:site" content="@a_hoverbear" />
    <meta name="twitter:creator" content="@a_hoverbear" />
    <link rel="me" href="https:&#x2F;&#x2F;hachyderm.io&#x2F;@ana">

    <meta name="twitter:title"
        content="Raft Experiences and Repo Made Public!" />
    <meta property='og:title'
        content="Raft Experiences and Repo Made Public!" />

    <meta property='og:url'
        content="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;raft-update-1&#x2F;" />

    <meta name="twitter:description"
        content="
TL;DR: I&#x27;ve made Hoverbear&#x2F;raft publicly available (It&#x27;s still not ready)! Feel encouraged to contribute feedback or code via Github or email!

" />
    <meta property='og:description'
        content="
TL;DR: I&#x27;ve made Hoverbear&#x2F;raft publicly available (It&#x27;s still not ready)! Feel encouraged to contribute feedback or code via Github or email!

" />


    <!-- Talk about the homepage and the rss feed. -->
    <link rel="canonical"
        href="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;raft-update-1&#x2F;">
    <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">

    <!-- Stylesheets are fun -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Delius&family=Fira+Code&family=Noto+Sans&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />

    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css"
        integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"
        integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O"
        crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js"
        integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>

<body>
    
<div id="hero-wrapper">
    <figure class="enriched " style="">
       <figcaption>Photo&nbsp;- <a href="https://unsplash.com/photos/-N0cgDSF_MI">Kobi Li</a></figcaption>
       

<img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;fd9cec75a970c38f00.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg 3840w
              " sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,set 
                     3840px" src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;fd9cec75a970c38f00.jpg" alt="Photo" />
</figure>
</div>
<header>
    <div class="content">
        <h1 id="main-title"><a id="main-link" href="https:&#x2F;&#x2F;hoverbear.org">
                Raft Experiences and Repo Made Public!
            </a></h1>

        <nav id="tree">
    <ul>
        <li>
            <a href="https://hoverbear.org/about/">
                Ana, Hoverbear üêª
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/blog/">
                Articles
            </a>&nbsp;
        </li></ul><ul>
        </ul><ul>
        </ul>
</nav>

        <div class="metadata">
            <h5 class="description">
                A computer scientist working in open source towards a more hopeful future.
            </h5>

            <p class="date">
                Posted on 2015-02-05, around 6 minutes of reading.
            </p>
        </div>
    </div>
</header>

<main>
    
<nav id=toc>
    <ol>
        
        <li>
            <a href="https://hoverbear.org/blog/raft-update-1/#progress">Progress</a>
            
            <ol>
                
                <li>
                    <a href="https://hoverbear.org/blog/raft-update-1/#data-interchange">Data Interchange</a>
                </li>
                
                <li>
                    <a href="https://hoverbear.org/blog/raft-update-1/#interfacing">Interfacing</a>
                </li>
                
                <li>
                    <a href="https://hoverbear.org/blog/raft-update-1/#event-loop">Event Loop</a>
                </li>
                
            </ol>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/raft-update-1/#experience">Experience</a>
            
            <ol>
                
                <li>
                    <a href="https://hoverbear.org/blog/raft-update-1/#decoding-socket-data">Decoding Socket Data</a>
                </li>
                
                <li>
                    <a href="https://hoverbear.org/blog/raft-update-1/#dealing-with-the-state-machine">Dealing with the State (Machine)</a>
                </li>
                
                <li>
                    <a href="https://hoverbear.org/blog/raft-update-1/#dealing-with-non-pollables">Dealing with Non-Pollables</a>
                </li>
                
            </ol>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/raft-update-1/#thoughts">Thoughts</a>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/raft-update-1/#explore-and-help">Explore and Help!</a>
            
        </li>
        
    </ol>
</nav>

    <blockquote>
<p>TL;DR: I've made <a rel="noopener" target="_blank" href="https://github.com/Hoverbear/raft">Hoverbear/raft</a> publicly available <em>(It's still not ready)</em>! Feel encouraged to contribute feedback or code via Github or email!</p>
</blockquote>
<span id="continue-reading"></span><h2 id="progress">Progress</h2>
<p>I've been working hard on building a sane, reasonable scaffolding for the codebase. <a href="/2015/01/25/raft-so-far/">Last post</a> I talked about my first 'go' at designing the data structures and interfaces for the library, here I'll talk a bit about what's changed and why.</p>
<h3 id="data-interchange">Data Interchange</h3>
<p>Probably one of the most interesting (and meaningful) changes I've made was moving my previous enum structs into seperate enums and structs.</p>
<p>Simply, this:</p>
<pre class="z-code"><code><span class="z-text z-plain">enum ClientRequest&lt;T&gt; {
</span>    IndexRange {
</span>        start_index: u64,
</span>        end_index: u64,
</span>    },
</span>    AppendEntries {
</span>        prev_log_index: u64,
</span>        prev_log_term: T,
</span>        entries: Vec&lt;T&gt;,
</span>    },
</span>}
</span></code></pre>
<p>Became this:</p>
<pre class="z-code"><code><span class="z-text z-plain">#[derive(RustcEncodable, RustcDecodable, Debug, Clone)]
</span>pub enum ClientRequest&lt;T&gt; {
</span>    /// Gets the log entries from start to end.
</span>    IndexRange(IndexRange),
</span>    /// Asks the node to append an entry after a given entry.
</span>    AppendRequest(AppendRequest&lt;T&gt;),
</span>}

</span>#[derive(RustcEncodable, RustcDecodable, Debug, Clone, Copy)]
</span>pub struct IndexRange {
</span>    pub start_index: u64,
</span>    pub end_index: u64,
</span>}

</span>#[derive(RustcEncodable, RustcDecodable, Debug, Clone)]
</span>pub struct AppendRequest&lt;T&gt; {
</span>    pub prev_log_index: u64,
</span>    pub prev_log_term: T,
</span>    pub entries: Vec&lt;T&gt;,
</span>}
</span></code></pre>
<p>So... <em>Why?</em> A couple of reasons actually:</p>
<ol>
<li><del><strong>Enum structs take the memory of their biggest variant.</strong> This is a minor concern to me as most of my structs are just a few values large, but I understand how this can have an effect and I'd like to follow best practices.</del> <a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/2ux7xo/raft_experiences_part_1_and_repo_made_public/cocqx4d">(The change made did not benefit from this. See this comment by Quxxy)</a></li>
<li><strong>You lose type safety.</strong> There is no way to create a function that will only accept a single variant of an enum. You can't, for example, say <code>fn foo(bar: Option::None) {}</code>. Moving to seperate structs means that the compiler can check to make sure the right data is being passed into the right functions.</li>
</ol>
<p><em>What's the downside?</em> Creating a new <code>AppendRequest</code> without the use of a helper function can look a little gross: <code>ClientRequest::AppendRequest(AppendRequest { ... })</code></p>
<p>But a helper can mask this grossness:</p>
<pre class="z-code"><code><span class="z-text z-plain">impl&lt;T&gt; ClientRequest&lt;T&gt; {
</span>    /// Returns (term, success)
</span>    pub fn index_range(start: u64, end: u64) -&gt; ClientRequest&lt;T&gt; {
</span>        ClientRequest::IndexRange(IndexRange {
</span>            start_index: start,
</span>            end_index: end,
</span>        })
</span>    }

</span>    /// Returns (term, voteGranted)
</span>    pub fn append_request(prev_log_index: u64, prev_log_term: T, entries: Vec&lt;T&gt;) -&gt; ClientRequest&lt;T&gt; {
</span>        ClientRequest::AppendRequest(AppendRequest {
</span>            prev_log_index: prev_log_index,
</span>            prev_log_term: prev_log_term,
</span>            entries: entries
</span>        })
</span>    }
</span>}
</span></code></pre>
<h3 id="interfacing">Interfacing</h3>
<p>A <code>RaftNode</code> now is spawned via the following function</p>
<pre class="z-code"><code><span class="z-text z-plain">pub fn start (id: u64, nodes: Vec&lt;(u64, SocketAddr)&gt;) -&gt;
</span>(Sender&lt;ClientRequest&lt;T&gt;&gt;, Receiver&lt;Result&lt;Vec&lt;T&gt;, String&gt;&gt;)
</span></code></pre>
<p>Well isn't that a long function signature? Basically, once you spawn a RaftNode it gets <em>immediately</em> moved into it's own thread and you are given a pair of channels to talk to it over. You send <code>ClientRequest</code>s and get back the rather familiar <code>Result</code> type. In the future it might be beneficial to expose something other than channels, but currently I think that's the best choice.</p>
<blockquote>
<p>I'm still wrangling ownership and borrowing, as I think many Rust users are, and some of my design choices are specifically because I wanted to avoid friction for now.</p>
</blockquote>
<p>Since I've not been a user of any of the other Raft implementations out there (other than a bit of playing with <a rel="noopener" target="_blank" href="https://github.com/coreos/etcd"><code>etcd</code></a>) I don't have much of a basis to go off what's a &quot;nice&quot; interface. My goal is to remove as much of the complexities and management of the library from the user as possible. Ideally once they start their <code>RaftNode</code>s they'll only need to worry about sending requests and getting responses.</p>
<h3 id="event-loop">Event Loop</h3>
<p>I took a look at <a rel="noopener" target="_blank" href="https://github.com/carllerche/mio"><code>mio</code></a> which looks fantastic, however for the time being I'm still just doing an infinite <code>loop</code> as I'd like to keep dependencies <em>down</em> until Rust stabilizes a bit more. In the future using some sort of evented system would definitely be ideal.</p>
<h2 id="experience">Experience</h2>
<h3 id="decoding-socket-data">Decoding Socket Data</h3>
<p>I had all sorts of fun implementing the following code in the loop's main <code>tick()</code> function:</p>
<pre class="z-code"><code><span class="z-text z-plain">match self.socket.recv_from(&amp;mut read_buffer) {
</span>    Ok((num_read, source)) =&gt; { // Something on the socket.
</span>        // This is possibly an RPC from another node. Try to parse it out
</span>        // and determine what to do based on it&#39;s variant.
</span>        let data = str::from_utf8(&amp;mut read_buffer[.. num_read])
</span>            .unwrap();
</span>        if let Ok(rpc) = json::decode::&lt;RemoteProcedureCall&lt;T&gt;&gt;(data) {
</span>            match rpc {
</span>                RemoteProcedureCall::RequestVote(call) =&gt;
</span>                    self.handle_request_vote(call, source),
</span>                RemoteProcedureCall::AppendEntries(call) =&gt;
</span>                    self.handle_append_entries(call, source),
</span>            }
</span>        } else if let Ok(rpr) = json::decode::&lt;RemoteProcedureResponse&gt;(data) {
</span>            match rpr {
</span>                RemoteProcedureResponse::Accepted { .. } =&gt;
</span>                    self.handle_accepted(rpr, source),
</span>                RemoteProcedureResponse::Rejected { .. } =&gt;
</span>                    self.handle_rejected(rpr, source),
</span>            }
</span>        }
</span>    },
</span>    Err(_) =&gt; (),                 // Nothing on the socket.
</span>}
</span></code></pre>
<p>This was the first time I used <code>if let</code> and it was very useful for destructuring in control flow. I'm looking forward to using <code>while let</code> soon.</p>
<p><em>What does that code do... exactly?</em> When we recieve data from the network, it's either going to be a <code>RemoteProcedureCall</code>, a <code>RemoteProcedureResponse</code>, or something else entirely. Currently, I only account for the valid cases, the third case is outright ignored.</p>
<h3 id="dealing-with-the-state-machine">Dealing with the State (Machine)</h3>
<p>I read <a rel="noopener" target="_blank" href="https://gist.github.com/bvssvni/8970459">this gist</a> with great interest, however I've yet to determine how to go about implementing a truly type-safe state machine for Raft right now. I'd like to do this in the future, and I'd be thrilled if someone could help with advice, mentorship, or pull requests on how to accomplish this.</p>
<p>Currently, all of the data event handlers look roughly like this:</p>
<pre class="z-code"><code><span class="z-text z-plain">fn handle_append_request(&amp;mut self, request: AppendRequest&lt;T&gt;) {
</span>    match self.state {
</span>        Leader(ref state) =&gt; {
</span>            unimplemented!();
</span>        },
</span>        Follower =&gt; {
</span>            unimplemented!();
</span>        },
</span>        Candidate =&gt; {
</span>            unimplemented!();
</span>        },
</span>    }
</span>}
</span></code></pre>
<h3 id="dealing-with-non-pollables">Dealing with Non-Pollables</h3>
<p>One thing I noticed while working with Rust's <code>UdpSocket</code> imeplementation is there is no way to <code>poll()</code> the socket to see if there is data, so any time the socket is checked you <em>must</em> handle the data immediately. I'm currently avoiding having FIFO queues for the various data but that might end up being a requirement.</p>
<p>For those wondering, you can make a socket non-blocking by using this:</p>
<pre class="z-code"><code><span class="z-text z-plain">let mut socket = UdpSocket::bind(own_socket_addr)
</span>    .unwrap();
</span>socket.set_read_timeout(Some(0));
</span></code></pre>
<h2 id="thoughts">Thoughts</h2>
<p>Working with Rust has been <strong>really fun</strong>. <em>(Except when there is a breaking change which cascades through libraries and means you lose productivity.)</em></p>
<p><strong><code>match</code> expressions</strong> are incredible things. If you haven't played around with Rust yet, they're so much more than a <code>switch</code> statement in your run of the mill language.</p>
<p><strong>API design</strong> in Rust is very versatile and interesting. The strong typing and ownership system encourage you to work with data in sane and creative ways.</p>
<p><strong>Understanding your code</strong> is emphasized in Rust far more than a language like Javascript. Understanding where your borrows come from, what lifetimes are applicable, etc are all valuable to you.</p>
<p><strong>Smart data structures and dumb code are better than vice versa...</strong> and I think that Rust really helps with that.</p>
<h2 id="explore-and-help">Explore and Help!</h2>
<blockquote>
<p>https://github.com/Hoverbear/raft</p>
</blockquote>
<p>Would you like to explore, give feedback, or contribute? Please do! Publicly you can just make an issue on Github, or privately just shoot me an email. (I'm <em>sure</em> you can find it on Github or here...)</p>
<p><strong>Discussion of this post is on <a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/2ux7xo/raft_experiences_part_1_and_repo_made_public/">Reddit</a>.</strong></p>

</main>
<footer class="post-footer">
    Connect through &nbsp<a href="mailto:operator@hoverbear.org">operator@hoverbear.org</a>,&nbsp;
    <a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;
    <a rel="me" href="https:&#x2F;&#x2F;hachyderm.io&#x2F;@ana">@ana@hachyderm.io</a> on Mastodon,</a>&nbsp;
    <a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
    or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
</footer>
<pre
        class="artifact"><a id="commit" href="https://github.com/Hoverbear/hoverbear.org/commit/031233137212d8b53197b56d3b598ba4306688f6
">031233137212d8b53197b56d3b598ba4306688f6
</a></pre></body>

</html>