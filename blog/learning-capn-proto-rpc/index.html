<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>Learning Cap&#x27;n Proto RPC</title>
        <meta name="description" content="A computer scientist working in open source towards a more hopeful future." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg">
        <meta name="twitter:site" content="@a_hoverbear">
        <meta name="twitter:creator" content="@a_hoverbear">
        
            <meta name="twitter:title" content="Learning Cap&#x27;n Proto RPC">
        
        
            <meta name="twitter:description" content="Awhile ago, I wrote a First Look at Cap&#x27;n Proto. Unfortunately I didn&#x27;t cover how to utilize it&#x27;s RPC capabilities. In Rust, this is via the capnp-rpc-rust crate.
Let&#x27;s do that!
">
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;hoverbear.org/font/fira_code/fira_code.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;hoverbear.org/font/fira/fira.css">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    

    <body>
        <header><div id="hero-wrapper">
        <div class="content"><h1><a href="https:&#x2F;&#x2F;hoverbear.org">Learning Cap&#x27;n Proto RPC</a></h1>
                <p class="description"></h1><nav id="pages">
                <ul>
                    <li><a href="/">Home</a></li>
                    <li><a href="/consulting/">Consulting</a></li>
                    <li><a href="/about/">About</a></li>
                    <li><a href="/tags/">By Tag</a></li>
                </ul>
            </nav>
        </div>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a3aed6e7b2f3210400.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;2851c84fd6c5141000.jpg"
              alt="" />
    </div>
</header>
      

        <main>
            <article>
                
    <nav id=toc>
        <ol>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#what-s-rpc">What&#x27;s RPC?</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#our-example">Our Example</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#in-the-schema">In the Schema</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#building-off-stubs">Building Off Stubs</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#working-with-context">Working with Context</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#erecting-a-server">Erecting a Server</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#working-with-a-client">Working with a Client</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#further-exploration">Further Exploration</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/learning-capn-proto-rpc/#closing-thoughts">Closing Thoughts</a>
                
            </li>
            
        </ol>
    </nav>

                
    <p>Awhile ago, I wrote a <a href="/2015/02/11/capn-proto-in-rust/">First Look at Cap'n Proto</a>. Unfortunately I didn't cover how to utilize it's RPC capabilities. In Rust, this is via the <a href="https://github.com/dwrensha/capnp-rpc-rust"><code>capnp-rpc-rust</code></a> crate.</p>
<p>Let's do that!</p>
<span id="continue-reading"></span><h2 id="what-s-rpc">What's RPC?</h2>
<p>Remote Procedure Calls (RPC) are basically what they say on the box. You issue one from some client to some server and the server responds (or not!) with some response.</p>
<p>Most protocols have some form of language-agnostic schema, not unlike SQL I suppose, which they use to describe interchange data (<code>struct</code>s and <code>fn</code>s). A tool is generally used to create a <strong>stub</strong>, which the programmer then architects.</p>
<blockquote>
<p>One of the orgininal Remote Procedure Call papers can be found <a href="http://research.cs.wisc.edu/areas/os/Qual/papers/rpc.pdf">here</a>. Cap'n Proto has it's own <a href="https://capnproto.org/rpc.html">RPC Spec</a>.</p>
</blockquote>
<p>So if you want to <code>foo()</code> on <code>bar</code> you can do that. But how is this different than just shuffling off packets to one another?</p>
<p><strong>Networks are unreliable and unordered.</strong> Your UDP packets might get dropped, reordered, or mishandled. <em>&quot;Ha! I'll use TCP!&quot;</em> You say? Sure, okay, this solves part of the issue. Are you willing to pay the round-trips? What happens when the other host goes down? What happens when the router dies? How do you respond to your client? A protocol like Cap'n Proto has more well defined failure modes.</p>
<p><strong>You don't need to keep track of so many things.</strong> Say we're using UDP, that means we need to label packets and track which ones we haven't recieved responses for. Okay, sure, what happens when we have a couple get lost? Do you &quot;garbage collect&quot; them? Do they leak forever? Using TCP? You're no much better off, you need to either pay the handshake cost <em>every call</em> or track all those connections!</p>
<p><strong>It implements a more understandable interface.</strong> You write code once, then you read it many more times. Then you rewrite it, then cycle repeats. How often do you want to spend trying to trace packets through your application? Does it scale? Do you really expect contributors to understand your mess? RPCs look and feel more like Local Procedure Calls (LPC) and can make things easier to comprehend.</p>
<h2 id="our-example">Our Example</h2>
<p>Today we'll be implementing mock calls for the <a href="http://ramcloud.stanford.edu/raft.pdf">Raft</a> protocol. <strong>On page 4</strong> you'll find the calls that we'll be implementing.</p>
<p>In short:</p>
<ul>
<li><code>AppendEntries</code> which appends entries to a replicated log on all other Raft nodes in the cluster.</li>
<li><code>RequestVote</code> which a <code>Candidate</code> uses to request the vote of other nodes so it may become a <code>Leader</code>.</li>
</ul>
<p>There is also another call specified, but that is left as practice for the reader. (Feel free to share your results!)</p>
<h2 id="in-the-schema">In the Schema</h2>
<p>Cap'n Proto uses <code>interface</code> to declare calls. Let's take a look what will be <code>src/schema/raft.capnp</code>:</p>
<pre style="background-color:#2b303b;">
@0xf64213cd3ccb41d5;
# unique file ID, generated by `capnp id`

interface Raft {
    appendEntries @0 (term :UInt64,
                      leaderId :UInt64,
                      prevLogIndex :UInt64,
                      prevLogTerm :UInt64,
                      entries :List(Text),
                      leaderCommit :UInt64)
                      -&gt; (term :UInt64, success :Bool);
    requestVote @1 (term :UInt64,
                    candidateId :UInt64,
                    lastLogIndex :UInt64,
                    lastLogTerm :UInt64)
                    -&gt; (term :UInt64, voteGranted :Bool);
}
</pre>
<p>Just like in the structs we declared in the previous article, these are also decorated with <code>@n</code>. Again, it's probably a good idea to keep them in order.</p>
<p>One neat thing is <strong>multiple returns</strong>. This means you can return more than just a single struct or value from a call.</p>
<p>One gotcha is that, as in the previous article, the data types don't translate directly into familiar interfaces. For example, I was not able to successfully create a <code>:List(Text)</code> from a vector, some adaptation is required.</p>
<blockquote>
<p>If you don't have Cap'n Proto set up yet (or it's out of date) you can follow the instructions <a href="http://www.hoverbear.org/2015/02/12/capn-proto-in-rust/#capnproto">here</a>.</p>
</blockquote>
<p>From here, you can generate your <code>.rs</code> file.</p>
<pre style="background-color:#2b303b;">
capnp compile -o rust src/schema/*.capnp
</pre>
<p>You should now see <code>src/schema/raft_capnp.rs</code> and it will contain the generated implementation. In RPC terms, this are your <strong>stubs</strong>.</p>
<p><em>Don't cross your eyes too much at that code.</em> The just of it is that Cap'n Proto is mostly driven by <code>Reader</code> and <code>Builder</code> implementations. You also might notice that <code>List</code> types need to be constructed a bit differently.</p>
<blockquote>
<p>This all might feel a bit weird because Cap'n Proto lays things out in memory such that they are <strong>serialized at rest, before being sent</strong>. <a href="https://capnproto.org/encoding.html">Read more on the encoding...</a></p>
</blockquote>
<h2 id="building-off-stubs">Building Off Stubs</h2>
<p>Before we even get into Rust code make sure you have the following packages in your <code>Cargo.toml</code>:</p>
<pre style="background-color:#2b303b;">
[dependencies]
capnp = &quot;*&quot;
capnpc = &quot;*&quot;
capnp-rpc = &quot;*&quot;
</pre>
<p>In <code>src/main.rs</code> of our test project we'll need to have some imports:</p>
<pre style="background-color:#2b303b;">
extern crate capnp;
extern crate capnpc;
extern crate &quot;capnp-rpc&quot; as capnp_rpc;
mod raft_capnp {
    include!(&quot;./schema/raft_capnp.rs&quot;);
}
use std::thread;
use raft_capnp::raft as Raft;
use capnp::capability::{FromServer, Server};
use capnp_rpc::capability::{InitRequest, LocalClient, WaitForContent};
use capnp_rpc::ez_rpc::{EzRpcServer, EzRpcClient};
</pre>
<p><em>Note:</em> Because <code>capnp-rpc</code> is not a valid crate name we need to alias it. We'll also use <code>mod raft_capnp { include!(...) }</code> because of some <a href="https://github.com/dwrensha/capnpc-rust/issues/5">scoping issues with the Cap'n Proto implementation</a>. Since our <code>raft_capnp::raft</code> would normally be capitalized if it were a native Rust implementation I've gone ahead and done that as well.</p>
<p>Next, in order to make our stubs something more than just <em>nothing</em> we'll go ahead and implement them. In our case, <code>RaftImpl</code> is an empty struct since we're just fiddling. But this is a good place to put stateful things since the handlers will recieve a <code>&amp;mut self</code>.</p>
<pre style="background-color:#2b303b;">
struct RaftImpl;
impl Raft::Server for RaftImpl {
    fn append_entries(&amp;mut self, mut context: Raft::AppendEntriesContext) { }
    fn request_vote(&amp;mut self, mut context: Raft::RequestVoteContext) { }
}
</pre><h2 id="working-with-context">Working with Context</h2>
<p>So you might have looked at the parameters to our calls and realized <em>they don't look anything like the ones we wrote in the schema</em>. They show up in <code>mut context</code>.</p>
<blockquote>
<p><strong>Why?</strong> Because, like <code>struct</code>s in Cap'n Proto, RPC calls are also laid out in memory in creative ways. So we'll need to use getters to access them.</p>
</blockquote>
<p>Let's work through getting the parameters inside of our <code>AppendEntries</code> call.</p>
<pre style="background-color:#2b303b;">
let (params, mut results) = context.get();
</pre>
<p>So <code>context</code> breaks down into the <code>params</code>, and the <code>results</code>. The idea is that you read from the params and write to the (mutable) results.</p>
<pre style="background-color:#2b303b;">
let term = params.get_term();
let leader_id = params.get_leader_id();
let prev_log_index = params.get_prev_log_index();
let prev_log_term = params.get_prev_log_term();
let leader_commit = params.get_leader_commit();
</pre>
<p>Accessors look pretty standard here, the parameters come out as types we'd expect (In this case, <code>u64</code>). For a List things are a bit different.</p>
<pre style="background-color:#2b303b;">
let entries = {
    let target = params.get_entries();
    let size = target.len();
    let mut entries = Vec::with_capacity(size as usize);
    for i in 0..size {
        entries.push(target.get(i).to_string());
    }
    entries
};
</pre>
<p>Unfortunately, I wasn't able to figure out a painless way of extracting a full set of values from the list without doing a manual walk like this. However, if you're working with 'real' code you might be able to avoid such things. <strong>The scope is important here, note how we limit it.</strong></p>
<p>At the end of the call we can set the results and close the context.</p>
<pre style="background-color:#2b303b;">
results.set_term(1u64);
results.set_success(true);

context.done();
</pre>
<p>After, Cap'N Proto will go and return our results. It should be noted that some cases requests can be <em>piplined</em> into other requests. I haven't dug too deeply into this yet but you can explore more <a href="https://github.com/dwrensha/capnp-rpc-rust/tree/master/examples/calculator">in this example</a>. Once I have a more firm understanding of things I'll probably write about pipelining.</p>
<h2 id="erecting-a-server">Erecting a Server</h2>
<p>The server part of our application will consume our <code>RaftImpl</code> and listen on a specific address. In order to simplify testing, we'll kick it off into a new thread because once <code>.serve()</code> is called the thread will block.</p>
<pre style="background-color:#2b303b;">
thread::spawn(move || {
    let rpc_server = EzRpcServer::new(&quot;localhost:8080&quot;).unwrap();
    let raft_server = Box::new(Raft::ServerDispatch { server : Box::new(RaftImpl)}) as Box&lt;Server+Send&gt;;
    rpc_server.serve(raft_server);
});
</pre>
<p>In the RPC repository's example, <a href="https://github.com/dwrensha">@dwrensha</a> mentiones that there should be a better way to create <code>raft_server</code> but I've not been able to find any myself. If you have suggestions please <a href="https://github.com/dwrensha/capnp-rpc-rust/issues">speak your peace</a>!</p>
<h2 id="working-with-a-client">Working with a Client</h2>
<p>Creating a client is fairly straightforward, the only thing I would note is that the <code>::new(&quot;$ADDRESS&quot;)</code> parameter is the <strong>server</strong>'s address.</p>
<pre style="background-color:#2b303b;">
let mut rpc_client = EzRpcClient::new(&quot;localhost:8080&quot;).unwrap();
let raft_client: Raft::Client = rpc_client.get_main();
</pre>
<p>Finally, creating a request involves using the <code>Builder</code> implementation from the Rust code we generated from the Schema. Again, creating a <code>List</code> is a bit different than you might be used to.</p>
<pre style="background-color:#2b303b;">
println!(&quot;Issuing append_entries.&quot;);
{
    let mut request = raft_client.append_entries_request();
    let mut builder = request.init();

    builder.set_term(0u64);
    builder.set_leader_id(0u64);
    builder.set_prev_log_index(0u64);
    builder.set_prev_log_term(0u64);
    // Do entries in a sec.
    builder.set_leader_commit(0u64);
    // Entry creation is scoped.
    {
        let mut entries = builder.init_entries(2u32);
        entries.set(0, &quot;Foo&quot;);
        entries.set(1, &quot;Bar&quot;);
    }
    let mut promise = request.send();

    let response = promise.wait().unwrap();
    let term = response.get_term();
    let success = response.get_success();
}
</pre><h2 id="further-exploration">Further Exploration</h2>
<p>These are unsolved problems that I've been working on which I'm hoping the community can offer suggestions on. I'll update this post and credit any bright ideas!</p>
<p><strong>Issuing calls to many servers at the same time</strong>. Simply attempting to <code>.wait()</code> in a loop is wholly inadequate for the implementation of <code>RequestVote</code>. How can we do better? Perhaps with multiple clients and a 'barrier'? <a href="https://github.com/dwrensha/capnp-rpc-rust/issues/5">Issue here</a>.</p>
<pre style="background-color:#2b303b;">
// TODO
</pre>
<p><strong>Having other events occuring on the server thread.</strong> In our implementation of <a href="https://github.com/hoverbear/raft">Raft</a> we'd ideally like to keep the requirements of a <code>RaftNode</code> down to a single thread, but we need to have timer events. I'm curious if this might be able to integrate with <a href="https://github.com/carllerche/mio">MIO</a> to do this.</p>
<pre style="background-color:#2b303b;">
// TODO
</pre>
<p><strong>Pipelining multiple requests.</strong> Cap'n Proto has a feature called &quot;Pipelining&quot; which allows you to make multiple RPC calls in only one network trip (with some limitations). I have yet to come up with an understandable, simple example for this, suggestions?</p>
<pre style="background-color:#2b303b;">
// TODO
</pre><h2 id="closing-thoughts">Closing Thoughts</h2>
<p>As before, one of the biggest stumbling blocks to using Cap'n Proto in Rust is the lack of documentation. There are only a few examples and the majority of the code does not have <code>rustdoc</code> comments, so exploring the API is usually a best-effort attempt. If you have an interest in writing documentation I'd highly suggest this project!</p>
<p>I think that Cap'n Prot's RPC mechanisms offer something better then just shuffling around packets. In addition to allowing for more comprehension, it can also improve compatability and speed.</p>
<blockquote>
<p>This post is discussed on <a href="https://www.reddit.com/r/rust/comments/2yp7cb/learning_capn_proto_rpc/">Reddit</a>.</p>
</blockquote>
<blockquote>
<p>You can play with the full code <a href="https://gist.github.com/Hoverbear/7099220c233ecdf7fe8b">here</a>.</p>
</blockquote>
<blockquote>
<p>Thanks to <a href="http://github.com/dwrensha/">@dwrensha</a> for proofreading this!</p>
</blockquote>


            </article>
        </main>
        
        <footer class="post-footer">
    <div id="hero-wrapper"><img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a3aed6e7b2f3210400.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;2851c84fd6c5141000.jpg"
              alt="" /><div class="content">
            <h4><a href=/>← Back to top of index</a></h4>
        
            <h4>By Ana Hobden</h4><p>
                Connect through&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
                or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
            </p><p>Built from <a href="https://github.com/Hoverbear/hoverbear.org/commit/ref: refs&#x2F;heads&#x2F;master
"><code>ref: refs&#x2F;heads&#x2F;master
</code></a></p>
        </div>
    </div>
</footer>
            
    </body>

</html>
