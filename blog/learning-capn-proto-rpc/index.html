<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>Learning Cap&#x27;n Proto RPC</title>
        <meta name="description" content="Musings of a distributed systems engineer working remotely in western Canada." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg">
        <meta name="twitter:site" content="@a_hoverbear">
        <meta name="twitter:creator" content="@a_hoverbear">
        
            <meta name="twitter:title" content="Learning Cap&#x27;n Proto RPC">
        
        
            <meta name="twitter:description" content="Awhile ago, I wrote a First Look at Cap&#x27;n Proto. Unfortunately I didn&#x27;t cover how to utilize it&#x27;s RPC capabilities. In Rust, this is via the capnp-rpc-rust crate.
Let&#x27;s do that!
">
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/feed.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;hoverbear.org/font/fira_code/fira_code.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;hoverbear.org/font/fira/fira.css">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    
    <body>
        <header><div id="hero-wrapper">
        <div class="content"><h1><a href="https:&#x2F;&#x2F;hoverbear.org">Learning Cap&#x27;n Proto RPC</a></h1>
                <p class="description"></h1><nav id="pages">
                <ul>
                    <li><a href="/blog/">Blog</a></li>
                    <li><a href="/about/">About</a></li>
                    <li><a href="/tags/">Tags</a></li>
                </ul>
            </nav>
        </div>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a3aed6e7b2f3210400.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;2851c84fd6c5141000.jpg"
              alt="" />
    </div>
</header>
      

        <main>
            <article>
                
    <p>Awhile ago, I wrote a <a href="/2015/02/11/capn-proto-in-rust/">First Look at Cap'n Proto</a>. Unfortunately I didn't cover how to utilize it's RPC capabilities. In Rust, this is via the <a href="https://github.com/dwrensha/capnp-rpc-rust"><code>capnp-rpc-rust</code></a> crate.</p>
<p>Let's do that!</p>
<p id="zola-continue-reading"><a name="continue-reading"></a></p>
<h2 id="what-s-rpc">What's RPC?</h2>
<p>Remote Procedure Calls (RPC) are basically what they say on the box. You issue one from some client to some server and the server responds (or not!) with some response.</p>
<p>Most protocols have some form of language-agnostic schema, not unlike SQL I suppose, which they use to describe interchange data (<code>struct</code>s and <code>fn</code>s). A tool is generally used to create a <strong>stub</strong>, which the programmer then architects.</p>
<blockquote>
<p>One of the orgininal Remote Procedure Call papers can be found <a href="http://research.cs.wisc.edu/areas/os/Qual/papers/rpc.pdf">here</a>. Cap'n Proto has it's own <a href="https://capnproto.org/rpc.html">RPC Spec</a>.</p>
</blockquote>
<p>So if you want to <code>foo()</code> on <code>bar</code> you can do that. But how is this different than just shuffling off packets to one another?</p>
<p><strong>Networks are unreliable and unordered.</strong> Your UDP packets might get dropped, reordered, or mishandled. <em>&quot;Ha! I'll use TCP!&quot;</em> You say? Sure, okay, this solves part of the issue. Are you willing to pay the round-trips? What happens when the other host goes down? What happens when the router dies? How do you respond to your client? A protocol like Cap'n Proto has more well defined failure modes.</p>
<p><strong>You don't need to keep track of so many things.</strong> Say we're using UDP, that means we need to label packets and track which ones we haven't recieved responses for. Okay, sure, what happens when we have a couple get lost? Do you &quot;garbage collect&quot; them? Do they leak forever? Using TCP? You're no much better off, you need to either pay the handshake cost <em>every call</em> or track all those connections!</p>
<p><strong>It implements a more understandable interface.</strong> You write code once, then you read it many more times. Then you rewrite it, then cycle repeats. How often do you want to spend trying to trace packets through your application? Does it scale? Do you really expect contributors to understand your mess? RPCs look and feel more like Local Procedure Calls (LPC) and can make things easier to comprehend.</p>
<h2 id="our-example">Our Example</h2>
<p>Today we'll be implementing mock calls for the <a href="http://ramcloud.stanford.edu/raft.pdf">Raft</a> protocol. <strong>On page 4</strong> you'll find the calls that we'll be implementing.</p>
<p>In short:</p>
<ul>
<li><code>AppendEntries</code> which appends entries to a replicated log on all other Raft nodes in the cluster.</li>
<li><code>RequestVote</code> which a <code>Candidate</code> uses to request the vote of other nodes so it may become a <code>Leader</code>.</li>
</ul>
<p>There is also another call specified, but that is left as practice for the reader. (Feel free to share your results!)</p>
<h2 id="in-the-schema">In the Schema</h2>
<p>Cap'n Proto uses <code>interface</code> to declare calls. Let's take a look what will be <code>src/schema/raft.capnp</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">@0xf64213cd3ccb41d5;
</span><span style="color:#c0c5ce;"># unique file ID, generated by `capnp id`

</span><span style="color:#c0c5ce;">interface Raft {
</span><span style="color:#c0c5ce;">    appendEntries @0 (term :UInt64,
</span><span style="color:#c0c5ce;">                      leaderId :UInt64,
</span><span style="color:#c0c5ce;">                      prevLogIndex :UInt64,
</span><span style="color:#c0c5ce;">                      prevLogTerm :UInt64,
</span><span style="color:#c0c5ce;">                      entries :List(Text),
</span><span style="color:#c0c5ce;">                      leaderCommit :UInt64)
</span><span style="color:#c0c5ce;">                      -&gt; (term :UInt64, success :Bool);
</span><span style="color:#c0c5ce;">    requestVote @1 (term :UInt64,
</span><span style="color:#c0c5ce;">                    candidateId :UInt64,
</span><span style="color:#c0c5ce;">                    lastLogIndex :UInt64,
</span><span style="color:#c0c5ce;">                    lastLogTerm :UInt64)
</span><span style="color:#c0c5ce;">                    -&gt; (term :UInt64, voteGranted :Bool);
</span><span style="color:#c0c5ce;">}
</span></pre>
<p>Just like in the structs we declared in the previous article, these are also decorated with <code>@n</code>. Again, it's probably a good idea to keep them in order.</p>
<p>One neat thing is <strong>multiple returns</strong>. This means you can return more than just a single struct or value from a call.</p>
<p>One gotcha is that, as in the previous article, the data types don't translate directly into familiar interfaces. For example, I was not able to successfully create a <code>:List(Text)</code> from a vector, some adaptation is required.</p>
<blockquote>
<p>If you don't have Cap'n Proto set up yet (or it's out of date) you can follow the instructions <a href="http://www.hoverbear.org/2015/02/12/capn-proto-in-rust/#capnproto">here</a>.</p>
</blockquote>
<p>From here, you can generate your <code>.rs</code> file.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">capnp compile -o rust src/schema/*.capnp
</span></pre>
<p>You should now see <code>src/schema/raft_capnp.rs</code> and it will contain the generated implementation. In RPC terms, this are your <strong>stubs</strong>.</p>
<p><em>Don't cross your eyes too much at that code.</em> The just of it is that Cap'n Proto is mostly driven by <code>Reader</code> and <code>Builder</code> implementations. You also might notice that <code>List</code> types need to be constructed a bit differently.</p>
<blockquote>
<p>This all might feel a bit weird because Cap'n Proto lays things out in memory such that they are <strong>serialized at rest, before being sent</strong>. <a href="https://capnproto.org/encoding.html">Read more on the encoding...</a></p>
</blockquote>
<h2 id="building-off-stubs">Building Off Stubs</h2>
<p>Before we even get into Rust code make sure you have the following packages in your <code>Cargo.toml</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">[dependencies]
</span><span style="color:#c0c5ce;">capnp = &quot;*&quot;
</span><span style="color:#c0c5ce;">capnpc = &quot;*&quot;
</span><span style="color:#c0c5ce;">capnp-rpc = &quot;*&quot;
</span></pre>
<p>In <code>src/main.rs</code> of our test project we'll need to have some imports:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">extern crate capnp;
</span><span style="color:#c0c5ce;">extern crate capnpc;
</span><span style="color:#c0c5ce;">extern crate &quot;capnp-rpc&quot; as capnp_rpc;
</span><span style="color:#c0c5ce;">mod raft_capnp {
</span><span style="color:#c0c5ce;">    include!(&quot;./schema/raft_capnp.rs&quot;);
</span><span style="color:#c0c5ce;">}
</span><span style="color:#c0c5ce;">use std::thread;
</span><span style="color:#c0c5ce;">use raft_capnp::raft as Raft;
</span><span style="color:#c0c5ce;">use capnp::capability::{FromServer, Server};
</span><span style="color:#c0c5ce;">use capnp_rpc::capability::{InitRequest, LocalClient, WaitForContent};
</span><span style="color:#c0c5ce;">use capnp_rpc::ez_rpc::{EzRpcServer, EzRpcClient};
</span></pre>
<p><em>Note:</em> Because <code>capnp-rpc</code> is not a valid crate name we need to alias it. We'll also use <code>mod raft_capnp { include!(...) }</code> because of some <a href="https://github.com/dwrensha/capnpc-rust/issues/5">scoping issues with the Cap'n Proto implementation</a>. Since our <code>raft_capnp::raft</code> would normally be capitalized if it were a native Rust implementation I've gone ahead and done that as well.</p>
<p>Next, in order to make our stubs something more than just <em>nothing</em> we'll go ahead and implement them. In our case, <code>RaftImpl</code> is an empty struct since we're just fiddling. But this is a good place to put stateful things since the handlers will recieve a <code>&amp;mut self</code>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">struct RaftImpl;
</span><span style="color:#c0c5ce;">impl Raft::Server for RaftImpl {
</span><span style="color:#c0c5ce;">    fn append_entries(&amp;mut self, mut context: Raft::AppendEntriesContext) { }
</span><span style="color:#c0c5ce;">    fn request_vote(&amp;mut self, mut context: Raft::RequestVoteContext) { }
</span><span style="color:#c0c5ce;">}
</span></pre><h2 id="working-with-context">Working with Context</h2>
<p>So you might have looked at the parameters to our calls and realized <em>they don't look anything like the ones we wrote in the schema</em>. They show up in <code>mut context</code>.</p>
<blockquote>
<p><strong>Why?</strong> Because, like <code>struct</code>s in Cap'n Proto, RPC calls are also laid out in memory in creative ways. So we'll need to use getters to access them.</p>
</blockquote>
<p>Let's work through getting the parameters inside of our <code>AppendEntries</code> call.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let (params, mut results) = context.get();
</span></pre>
<p>So <code>context</code> breaks down into the <code>params</code>, and the <code>results</code>. The idea is that you read from the params and write to the (mutable) results.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let term = params.get_term();
</span><span style="color:#c0c5ce;">let leader_id = params.get_leader_id();
</span><span style="color:#c0c5ce;">let prev_log_index = params.get_prev_log_index();
</span><span style="color:#c0c5ce;">let prev_log_term = params.get_prev_log_term();
</span><span style="color:#c0c5ce;">let leader_commit = params.get_leader_commit();
</span></pre>
<p>Accessors look pretty standard here, the parameters come out as types we'd expect (In this case, <code>u64</code>). For a List things are a bit different.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let entries = {
</span><span style="color:#c0c5ce;">    let target = params.get_entries();
</span><span style="color:#c0c5ce;">    let size = target.len();
</span><span style="color:#c0c5ce;">    let mut entries = Vec::with_capacity(size as usize);
</span><span style="color:#c0c5ce;">    for i in 0..size {
</span><span style="color:#c0c5ce;">        entries.push(target.get(i).to_string());
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    entries
</span><span style="color:#c0c5ce;">};
</span></pre>
<p>Unfortunately, I wasn't able to figure out a painless way of extracting a full set of values from the list without doing a manual walk like this. However, if you're working with 'real' code you might be able to avoid such things. <strong>The scope is important here, note how we limit it.</strong></p>
<p>At the end of the call we can set the results and close the context.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">results.set_term(1u64);
</span><span style="color:#c0c5ce;">results.set_success(true);

</span><span style="color:#c0c5ce;">context.done();
</span></pre>
<p>After, Cap'N Proto will go and return our results. It should be noted that some cases requests can be <em>piplined</em> into other requests. I haven't dug too deeply into this yet but you can explore more <a href="https://github.com/dwrensha/capnp-rpc-rust/tree/master/examples/calculator">in this example</a>. Once I have a more firm understanding of things I'll probably write about pipelining.</p>
<h2 id="erecting-a-server">Erecting a Server</h2>
<p>The server part of our application will consume our <code>RaftImpl</code> and listen on a specific address. In order to simplify testing, we'll kick it off into a new thread because once <code>.serve()</code> is called the thread will block.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">thread::spawn(move || {
</span><span style="color:#c0c5ce;">    let rpc_server = EzRpcServer::new(&quot;localhost:8080&quot;).unwrap();
</span><span style="color:#c0c5ce;">    let raft_server = Box::new(Raft::ServerDispatch { server : Box::new(RaftImpl)}) as Box&lt;Server+Send&gt;;
</span><span style="color:#c0c5ce;">    rpc_server.serve(raft_server);
</span><span style="color:#c0c5ce;">});
</span></pre>
<p>In the RPC repository's example, <a href="https://github.com/dwrensha">@dwrensha</a> mentiones that there should be a better way to create <code>raft_server</code> but I've not been able to find any myself. If you have suggestions please <a href="https://github.com/dwrensha/capnp-rpc-rust/issues">speak your peace</a>!</p>
<h2 id="working-with-a-client">Working with a Client</h2>
<p>Creating a client is fairly straightforward, the only thing I would note is that the <code>::new(&quot;$ADDRESS&quot;)</code> parameter is the <strong>server</strong>'s address.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">let mut rpc_client = EzRpcClient::new(&quot;localhost:8080&quot;).unwrap();
</span><span style="color:#c0c5ce;">let raft_client: Raft::Client = rpc_client.get_main();
</span></pre>
<p>Finally, creating a request involves using the <code>Builder</code> implementation from the Rust code we generated from the Schema. Again, creating a <code>List</code> is a bit different than you might be used to.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">println!(&quot;Issuing append_entries.&quot;);
</span><span style="color:#c0c5ce;">{
</span><span style="color:#c0c5ce;">    let mut request = raft_client.append_entries_request();
</span><span style="color:#c0c5ce;">    let mut builder = request.init();

</span><span style="color:#c0c5ce;">    builder.set_term(0u64);
</span><span style="color:#c0c5ce;">    builder.set_leader_id(0u64);
</span><span style="color:#c0c5ce;">    builder.set_prev_log_index(0u64);
</span><span style="color:#c0c5ce;">    builder.set_prev_log_term(0u64);
</span><span style="color:#c0c5ce;">    // Do entries in a sec.
</span><span style="color:#c0c5ce;">    builder.set_leader_commit(0u64);
</span><span style="color:#c0c5ce;">    // Entry creation is scoped.
</span><span style="color:#c0c5ce;">    {
</span><span style="color:#c0c5ce;">        let mut entries = builder.init_entries(2u32);
</span><span style="color:#c0c5ce;">        entries.set(0, &quot;Foo&quot;);
</span><span style="color:#c0c5ce;">        entries.set(1, &quot;Bar&quot;);
</span><span style="color:#c0c5ce;">    }
</span><span style="color:#c0c5ce;">    let mut promise = request.send();

</span><span style="color:#c0c5ce;">    let response = promise.wait().unwrap();
</span><span style="color:#c0c5ce;">    let term = response.get_term();
</span><span style="color:#c0c5ce;">    let success = response.get_success();
</span><span style="color:#c0c5ce;">}
</span></pre><h2 id="further-exploration">Further Exploration</h2>
<p>These are unsolved problems that I've been working on which I'm hoping the community can offer suggestions on. I'll update this post and credit any bright ideas!</p>
<p><strong>Issuing calls to many servers at the same time</strong>. Simply attempting to <code>.wait()</code> in a loop is wholly inadequate for the implementation of <code>RequestVote</code>. How can we do better? Perhaps with multiple clients and a 'barrier'? <a href="https://github.com/dwrensha/capnp-rpc-rust/issues/5">Issue here</a>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">// TODO
</span></pre>
<p><strong>Having other events occuring on the server thread.</strong> In our implementation of <a href="https://github.com/hoverbear/raft">Raft</a> we'd ideally like to keep the requirements of a <code>RaftNode</code> down to a single thread, but we need to have timer events. I'm curious if this might be able to integrate with <a href="https://github.com/carllerche/mio">MIO</a> to do this.</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">// TODO
</span></pre>
<p><strong>Pipelining multiple requests.</strong> Cap'n Proto has a feature called &quot;Pipelining&quot; which allows you to make multiple RPC calls in only one network trip (with some limitations). I have yet to come up with an understandable, simple example for this, suggestions?</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">// TODO
</span></pre><h2 id="closing-thoughts">Closing Thoughts</h2>
<p>As before, one of the biggest stumbling blocks to using Cap'n Proto in Rust is the lack of documentation. There are only a few examples and the majority of the code does not have <code>rustdoc</code> comments, so exploring the API is usually a best-effort attempt. If you have an interest in writing documentation I'd highly suggest this project!</p>
<p>I think that Cap'n Prot's RPC mechanisms offer something better then just shuffling around packets. In addition to allowing for more comprehension, it can also improve compatability and speed.</p>
<blockquote>
<p>This post is discussed on <a href="https://www.reddit.com/r/rust/comments/2yp7cb/learning_capn_proto_rpc/">Reddit</a>.</p>
</blockquote>
<blockquote>
<p>You can play with the full code <a href="https://gist.github.com/Hoverbear/7099220c233ecdf7fe8b">here</a>.</p>
</blockquote>
<blockquote>
<p>Thanks to <a href="http://github.com/dwrensha/">@dwrensha</a> for proofreading this!</p>
</blockquote>


            </article>
        </main>
        
        <footer class="post-footer">
    <div id="hero-wrapper"><img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a3aed6e7b2f3210400.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;a157fd2afbc5f18800.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;2851c84fd6c5141000.jpg"
              alt="" /><div class="content">
            <h4><a href=/>‚Üê Back to top of index</a></h4>
        
            <h4>By Ana Hobden</h4>
        
            <p>
                Connect through&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
                or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
            </p><p>Built from <a href="https://github.com/Hoverbear/hoverbear.org/commit/ref: refs&#x2F;heads&#x2F;master
"><code>ref: refs&#x2F;heads&#x2F;master
</code></a></p>
        </div>
    </div>
</footer>
            
    </body>

</html>
