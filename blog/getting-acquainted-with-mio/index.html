<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>Getting Acquainted with MIO
        </title>
        <meta name="description" content="A computer scientist working in open source towards a more hopeful future." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg"/>
        <meta property='og:image' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg"/>
        <meta name="twitter:site" content="@a_hoverbear"/>
        <meta name="twitter:creator" content="@a_hoverbear"/>
        
        
            <meta name="twitter:title" content="Getting Acquainted with MIO"/>
            <meta property='og:title' content="Getting Acquainted with MIO"/>
        

        
            <meta property='og:url' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;getting-acquainted-with-mio&#x2F;"/>
        

        
            <meta name="twitter:description" content="One of my next goals in my Raft project is to tame the tick() with mio. In this post, we&#x27;ll explore what it is, what it can do, and why it matters. First things first: What is MIO?

MIO is a lightweight IO library for Rust with a focus on adding as little overhead as possible over the OS abstractions.

"/>
            <meta property='og:description' content="One of my next goals in my Raft project is to tame the tick() with mio. In this post, we&#x27;ll explore what it is, what it can do, and why it matters. First things first: What is MIO?

MIO is a lightweight IO library for Rust with a focus on adding as little overhead as possible over the OS abstractions.

"/>
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Delius&family=Fira+Code&family=Noto+Sans&display=swap" rel="stylesheet">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    

    <body>
        
    <div id="hero-wrapper">
    <figure class="enriched ">
        <figcaption>Photo&nbsp;- <a href="https://unsplash.com/photos/-N0cgDSF_MI">Kobi Li</a></figcaption>
        
       
       <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;fd9cec75a970c38f00.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,set 
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;fd9cec75a970c38f00.jpg"
              alt="Photo" />
    </figure>
</div>

    <header>
    <div class="content">
        <h1 id="main-title"><a id="main-link" href="https:&#x2F;&#x2F;hoverbear.org">
            Getting Acquainted with MIO
        </a></h1>

        <nav id="tree"><ul><li>
            <a href="https://hoverbear.org/consulting/">
                Consulting Services
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/about/">
                Ana, Hoverbear üêª
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/blog/">
                Articles
            </a>&nbsp;
        </li></ul><ul></ul><ul></ul>
</nav>


        <div class="metadata">
            <p class="description">
                    A computer scientist working in open source towards a more hopeful future.
                </p>

            <p class="date">
                    Posted on 2015-03-03, around 7 minutes of reading.
                </p>
        </div>
    </div>
</header>

    <main>
        
    <nav id=toc>
        <ol>
            
            <li>
                <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#the-general-idea">The General Idea</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#hello-world">Hello, World</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#getting-a-handle-r">Getting a Handle(r)</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#registered-interest">Registered Interest</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#learn-more">Learn More</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#help-out">Help Out!</a>
                
            </li>
            
        </ol>
    </nav>

        <p>One of my next goals in my <a rel="noopener" target="_blank" href="http://hoverbear.org/tag/raft/">Raft</a> project is to tame the <code>tick()</code> with <a rel="noopener" target="_blank" href="https://github.com/carllerche/mio"><code>mio</code></a>. In this post, we'll explore what it is, what it can do, and why it matters. First things first: What is MIO?</p>
<blockquote>
<p>MIO is a lightweight IO library for Rust with a focus on adding as little overhead as possible over the OS abstractions.</p>
</blockquote>
<span id="continue-reading"></span>
<p>Now you're probably thinking... &quot;So what? We have plenty of shiny stuff in the new <code>std::io</code>...&quot; and you're right! But hold off on judgement until you read this:</p>
<blockquote>
<p>Features</p>
<ul>
<li>Event loop backed by <code>epoll</code>, <code>kqueue</code>.</li>
<li>Zero allocations at runtime</li>
<li>Non-blocking TCP, UDP and Unix domain sockets</li>
<li>High performance timer system</li>
<li>Thread safe message channel for cross thread communication</li>
</ul>
</blockquote>
<p>Okay, here it's starting to get interesting. <code>epoll</code>, and <code>kqueue</code> are event notification interfaces available in Linux, and the BSDs (Darwin included). Zero allocations are great for performance, and non-blocking sockets are insanely useful for network applications.</p>
<p>For a Raft context, the ability to use evented timers is applicable for heartbeats and election timings.</p>
<p>If you've used <code>node.js</code>, <code>io.js</code>, or Python's Twisted framework event loops might be familiar to you. <em>Yes I know callback hell sucks!</em> Fear not, this is Rust, not some scruffy loosely-typed, garbage-collected, non-blocking language!</p>
<h2 id="the-general-idea">The General Idea</h2>
<p>MIO works off this general concept:</p>
<ul>
<li>Make a thread for the <code>EventLoop</code>.</li>
<li>Register interest with <code>IOHandle</code>s.</li>
<li>Supply the loop with a <code>Handler</code>.</li>
<li>Run your code.</li>
</ul>
<h2 id="hello-world">Hello, World</h2>
<p>The following program is a nice, simple example of what MIO looks like:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>extern crate mio;
</span><span>use mio::*;
</span><span>use std::fmt::Debug;
</span><span>
</span><span>fn main() {
</span><span>    // Create an event loop
</span><span>    let mut event_loop = EventLoop::&lt;(), String&gt;::new().unwrap();
</span><span>    let sender = event_loop.channel();
</span><span>    sender.send(&quot;Hello&quot;.to_string()).unwrap();
</span><span>    // Start it
</span><span>    event_loop.run(&amp;mut BearHandler).unwrap();
</span><span>}
</span><span>
</span><span>struct BearHandler;
</span><span>
</span><span>impl&lt;T, M: Send + Debug&gt; Handler&lt;T, M&gt; for BearHandler {
</span><span>    /// A message has been delivered
</span><span>    fn notify(&amp;mut self, _reactor: &amp;mut EventLoop&lt;T, M&gt;, msg: M) {
</span><span>        println!(&quot;{:?}&quot;, msg);
</span><span>    }
</span><span>}
</span></code></pre>
<p>A <strong>lot</strong> is going on here. Let's take a closer look.</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>EventLoop::&lt;(), String&gt;::new();
</span></code></pre>
<p>This creates a new <code>EventLoop</code>. The Event loop uses <code>T</code> tokens of type <code>()</code>, and channels that consume and pass <code>M: Send</code> of type <code>String</code>. You can use anything that implements <code>Send</code> for messages.</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>event_loop.channel();
</span></code></pre>
<p>This gives us a channel to send <code>String</code>s. When we <code>send()</code> later our <code>BearHandler</code> wakes up and invokes <code>notify</code>.</p>
<p>From there, <code>notify</code> prints out the message. In a real application, this is where your business logic would be to determine what to do with the message.</p>
<h2 id="getting-a-handle-r">Getting a Handle(r)</h2>
<p>A Handler can implement some or all of the following functions:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>pub trait Handler&lt;T: Token, M: Send&gt; {
</span><span>    /// A registered IoHandle has available data to read
</span><span>    fn readable(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, hint: ReadHint, token: T);
</span><span>    /// A registered IoHandle is available to write to
</span><span>    fn writable(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, token: T);
</span><span>    /// A registered timer has expired
</span><span>    fn timeout(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, token: T);
</span><span>    /// A message has been delivered
</span><span>    fn notify(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, msg: M);
</span><span>    /// A signal has been delivered to the process
</span><span>    fn signal(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, info: mio::SigInfo);
</span><span>}
</span></code></pre>
<p>So this is a lot more then just sending some <code>String</code>s around! Did you doubt me?</p>
<p>What's really cool is your <code>Handler</code> can have a data backing since it's just a trait that you can implement yourself! Let's do that now:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>extern crate mio;
</span><span>use mio::*;
</span><span>
</span><span>fn main() {
</span><span>    // Create an event loop
</span><span>    let mut event_loop = EventLoop::&lt;(), u64&gt;::new().unwrap();
</span><span>    let sender = event_loop.channel();
</span><span>    for i in 0.. 5 {
</span><span>        sender.send(i).unwrap();
</span><span>    }
</span><span>    // Start it
</span><span>    event_loop.run(&amp;mut BearHandler(0)).unwrap();
</span><span>}
</span><span>
</span><span>struct BearHandler(u64);
</span><span>
</span><span>impl&lt;T&gt; Handler&lt;T, u64&gt; for BearHandler {
</span><span>    fn notify(&amp;mut self, _reactor: &amp;mut EventLoop&lt;T, u64&gt;, msg: u64) {
</span><span>        self.0 += msg;
</span><span>        println!(&quot;Message: {}, Total: {}&quot;, msg, self.0);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Output:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>Message: 0, Total: 0
</span><span>Message: 1, Total: 1
</span><span>Message: 2, Total: 3
</span><span>Message: 3, Total: 6
</span><span>Message: 4, Total: 10
</span></code></pre>
<p>In this case, our <code>BearHandler</code> was a humble <code>u64</code> tuple which we mutated, but you could easily make this a more complicated <code>struct</code>.</p>
<h2 id="registered-interest">Registered Interest</h2>
<p>Just sending messages isn't particularly interesting, let's wire up some new interests.</p>
<p>Alright, so let's take our humble little <code>BearHandler</code> and build it into a bit of a state mutation game:</p>
<ul>
<li>Each time a timer fire (every 250ms) send a UDP packet to some socket.</li>
<li>Each time that socket gets hit decrement a <code>count</code> by 1.</li>
<li>Each time on the channel increment it by that much.</li>
</ul>
<p>First, we'll modify the <code>BearHandler</code> to reflect these changes. First, we'll make it a proper <code>struct</code> and let it store a pair of sockets as well as it's <code>count</code>.</p>
<p>Second, we'll implement the <code>readable</code>, <code>timeout</code>, and <code>notify</code>. Note in the <code>readable</code> we take care to drain the socket. Also, note how the <code>timeout</code> doesn't need to reset itself, we can clear it with <a rel="noopener" target="_blank" href="https://carllerche.github.io/mio/mio/struct.EventLoop.html#method.clear_timeout"><code>clear_timeout</code></a> if we want.</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>impl Handler&lt;Token, u64&gt; for BearHandler {
</span><span>    fn readable(&amp;mut self, _reactor: &amp;mut EventLoop&lt;Token, u64&gt;, _token: Token, _hint: ReadHint) {
</span><span>        let mut buffer = buf::RingBuf::new(1024);
</span><span>        // Drain socket, otherwise infinite loop!
</span><span>        net::TryRecv::recv_from(&amp;self.listener, &amp;mut buffer.writer()).unwrap();
</span><span>        self.count -= 1;
</span><span>        println!(&quot;Decremented, Total: {}&quot;, self.count);
</span><span>    }
</span><span>    fn timeout(&amp;mut self, reactor: &amp;mut EventLoop&lt;Token, u64&gt;, _token: Token) {
</span><span>        self.sender.send_to(&amp;[0], &quot;127.0.0.1:12345&quot;).unwrap();
</span><span>        // Reset
</span><span>        reactor.timeout(TIMEOUT, Duration::milliseconds(250)).unwrap();
</span><span>        println!(&quot;Timeout&quot;);
</span><span>    }
</span><span>
</span><span>    fn notify(&amp;mut self, _reactor: &amp;mut EventLoop&lt;Token, u64&gt;, msg: u64) {
</span><span>        self.count += msg;
</span><span>        println!(&quot;Increment by: {}, Total: {}&quot;, msg, self.count);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Next, registering the various events, we'll use some of MIO's <code>mio::net</code> items:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>const LISTENER: Token = Token(0);
</span><span>const TIMEOUT:  Token = Token(1);
</span><span>fn main() {
</span><span>    // Create an event loop
</span><span>    let mut event_loop = EventLoop::&lt;Token, u64&gt;::new().unwrap();
</span><span>    // Register Interest
</span><span>    let listener = UdpSocket::bind(&quot;127.0.0.1:12345&quot;).unwrap();
</span><span>    event_loop.register(&amp;listener, LISTENER).unwrap(); // Token lets us distinguish.
</span><span>    // Increments
</span><span>    let incrementer = event_loop.channel();
</span><span>    for i in 0.. 5 {
</span><span>        incrementer.send(i).unwrap();
</span><span>    }
</span><span>    // Decrements
</span><span>    event_loop.timeout(TIMEOUT, Duration::milliseconds(250)).unwrap();
</span><span>    // Start it
</span><span>    let sender = UdpSocket::bind(&quot;127.0.0.1:12346&quot;).unwrap();
</span><span>    event_loop.run(&amp;mut BearHandler {
</span><span>        count: 0,
</span><span>        listener: listener,
</span><span>        sender: sender
</span><span>    }).unwrap();
</span><span>}
</span></code></pre>
<p>Output:</p>
<pre style="background-color:#212733;color:#ccc9c2;"><code><span>Increment by: 0, Total: 0
</span><span>Increment by: 1, Total: 1
</span><span>Increment by: 2, Total: 3
</span><span>Increment by: 3, Total: 6
</span><span>Increment by: 4, Total: 10
</span><span>Timeout
</span><span>Decremented, Total: 9
</span><span>Timeout
</span><span>Decremented, Total: 8
</span><span>Timeout
</span><span>Decremented, Total: 7
</span><span>Timeout
</span><span>Decremented, Total: 6
</span><span>Timeout
</span><span>Decremented, Total: 5
</span><span>Timeout
</span><span>Decremented, Total: 4
</span><span>Timeout
</span><span>Decremented, Total: 3
</span><span>Timeout
</span><span>Decremented, Total: 2
</span><span>Timeout
</span><span>Decremented, Total: 1
</span><span>Timeout
</span><span>Decremented, Total: 0
</span></code></pre>
<blockquote>
<p>By the way, in our examples MIO will take over the main thread and block. In a normal application you'll want to kick it off into a new thread when you <code>start()</code> it.</p>
</blockquote>
<h2 id="learn-more">Learn More</h2>
<ul>
<li>I found Wycats' <a rel="noopener" target="_blank" href="https://github.com/wycats/mio-book"><code>mio-book</code></a> repo very useful.</li>
<li>As always, the <a rel="noopener" target="_blank" href="https://carllerche.github.io/mio/mio/index.html">docs</a> were a great help.</li>
<li>This post is <a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/2xvtll/getting_acquainted_with_mio/"><strong>discussed on Reddit</strong></a>.</li>
<li>This post is also <a rel="noopener" target="_blank" href="https://news.ycombinator.com/item?id=9143255"><strong>discussed on Hacker News</strong></a>!</li>
</ul>
<h2 id="help-out">Help Out!</h2>
<p>We're tracking progress on integrating MIO into Raft with <a rel="noopener" target="_blank" href="https://github.com/Hoverbear/raft/issues/6">this issue</a>. Feel free to weigh in or help out!</p>
<blockquote>
<p>A <strong>huge</strong> thanks to <a rel="noopener" target="_blank" href="https://github.com/Hoverbear/raft/commits/master?author=danburkert"><strong>@danburkert</strong></a> for their contributions this week!</p>
</blockquote>

    </main>
    <footer class="post-footer">
    Connect through &nbsp<a href="mailto:operator@hoverbear.org">operator@hoverbear.org</a>,&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
    or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
</footer>
<pre class="artifact"><a id="commit" href="https://github.com/Hoverbear/hoverbear.org/commit/7957ab44c9e7493bface31f378b3b7b8b05072f0
">7957ab44c9e7493bface31f378b3b7b8b05072f0
</a></pre>
    </body>

</html>
