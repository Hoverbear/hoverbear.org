<!DOCTYPE html>
<html>
<head>
    <!-- Fun compatability things -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge"> <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">

    <!-- Information about this site -->
    <title>
        Getting Acquainted with MIO
    </title>
    <meta name="description"
        content="A computer scientist working in open source towards a more hopeful future." />

    <!-- Various Twitter related content. -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg" />
    <meta property='og:image' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg" />
    <meta name="twitter:site" content="@a_hoverbear" />
    <meta name="twitter:creator" content="@a_hoverbear" />
    <link rel="me" href="https:&#x2F;&#x2F;hachyderm.io&#x2F;@ana">

    <meta name="twitter:title"
        content="Getting Acquainted with MIO" />
    <meta property='og:title'
        content="Getting Acquainted with MIO" />

    <meta property='og:url'
        content="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;getting-acquainted-with-mio&#x2F;" />

    <meta name="twitter:description"
        content="One of my next goals in my Raft project is to tame the tick() with mio. In this post, we&#x27;ll explore what it is, what it can do, and why it matters. First things first: What is MIO?

MIO is a lightweight IO library for Rust with a focus on adding as little overhead as possible over the OS abstractions.

" />
    <meta property='og:description'
        content="One of my next goals in my Raft project is to tame the tick() with mio. In this post, we&#x27;ll explore what it is, what it can do, and why it matters. First things first: What is MIO?

MIO is a lightweight IO library for Rust with a focus on adding as little overhead as possible over the OS abstractions.

" />


    <!-- Talk about the homepage and the rss feed. -->
    <link rel="canonical"
        href="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;getting-acquainted-with-mio&#x2F;">
    <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">

    <!-- Stylesheets are fun -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Delius&family=Fira+Code&family=Noto+Sans&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />

    <!-- Katex -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css"
        integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js"
        integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O"
        crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js"
        integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</head>

<body>
    
<div id="hero-wrapper">
    <figure class="enriched " style="">
       <figcaption>Photo&nbsp;- <a href="https://unsplash.com/photos/-N0cgDSF_MI">Kobi Li</a></figcaption>
       

<img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;fd9cec75a970c38f00.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;bc53a992eae12b8000.jpg 3840w
              " sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,set 
                     3840px" src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;fd9cec75a970c38f00.jpg" alt="Photo" />
</figure>
</div>
<header>
    <div class="content">
        <h1 id="main-title"><a id="main-link" href="https:&#x2F;&#x2F;hoverbear.org">
                Getting Acquainted with MIO
            </a></h1>

        <nav id="tree">
    <ul>
        <li>
            <a href="https://hoverbear.org/about/">
                Ana, Hoverbear üêª
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/blog/">
                Articles
            </a>&nbsp;
        </li></ul><ul>
        </ul><ul>
        </ul>
</nav>

        <div class="metadata">
            <h5 class="description">
                A computer scientist working in open source towards a more hopeful future.
            </h5>

            <p class="date">
                Posted on 2015-03-03, around 7 minutes of reading.
            </p>
        </div>
    </div>
</header>

<main>
    
<nav id=toc>
    <ol>
        
        <li>
            <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#the-general-idea">The General Idea</a>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#hello-world">Hello, World</a>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#getting-a-handle-r">Getting a Handle(r)</a>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#registered-interest">Registered Interest</a>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#learn-more">Learn More</a>
            
        </li>
        
        <li>
            <a href="https://hoverbear.org/blog/getting-acquainted-with-mio/#help-out">Help Out!</a>
            
        </li>
        
    </ol>
</nav>

    <p>One of my next goals in my <a rel="noopener" target="_blank" href="http://hoverbear.org/tag/raft/">Raft</a> project is to tame the <code>tick()</code> with <a rel="noopener" target="_blank" href="https://github.com/carllerche/mio"><code>mio</code></a>. In this post, we'll explore what it is, what it can do, and why it matters. First things first: What is MIO?</p>
<blockquote>
<p>MIO is a lightweight IO library for Rust with a focus on adding as little overhead as possible over the OS abstractions.</p>
</blockquote>
<span id="continue-reading"></span>
<p>Now you're probably thinking... &quot;So what? We have plenty of shiny stuff in the new <code>std::io</code>...&quot; and you're right! But hold off on judgement until you read this:</p>
<blockquote>
<p>Features</p>
<ul>
<li>Event loop backed by <code>epoll</code>, <code>kqueue</code>.</li>
<li>Zero allocations at runtime</li>
<li>Non-blocking TCP, UDP and Unix domain sockets</li>
<li>High performance timer system</li>
<li>Thread safe message channel for cross thread communication</li>
</ul>
</blockquote>
<p>Okay, here it's starting to get interesting. <code>epoll</code>, and <code>kqueue</code> are event notification interfaces available in Linux, and the BSDs (Darwin included). Zero allocations are great for performance, and non-blocking sockets are insanely useful for network applications.</p>
<p>For a Raft context, the ability to use evented timers is applicable for heartbeats and election timings.</p>
<p>If you've used <code>node.js</code>, <code>io.js</code>, or Python's Twisted framework event loops might be familiar to you. <em>Yes I know callback hell sucks!</em> Fear not, this is Rust, not some scruffy loosely-typed, garbage-collected, non-blocking language!</p>
<h2 id="the-general-idea">The General Idea</h2>
<p>MIO works off this general concept:</p>
<ul>
<li>Make a thread for the <code>EventLoop</code>.</li>
<li>Register interest with <code>IOHandle</code>s.</li>
<li>Supply the loop with a <code>Handler</code>.</li>
<li>Run your code.</li>
</ul>
<h2 id="hello-world">Hello, World</h2>
<p>The following program is a nice, simple example of what MIO looks like:</p>
<pre class="z-code"><code><span class="z-text z-plain">extern crate mio;
</span>use mio::*;
</span>use std::fmt::Debug;

</span>fn main() {
</span>    // Create an event loop
</span>    let mut event_loop = EventLoop::&lt;(), String&gt;::new().unwrap();
</span>    let sender = event_loop.channel();
</span>    sender.send(&quot;Hello&quot;.to_string()).unwrap();
</span>    // Start it
</span>    event_loop.run(&amp;mut BearHandler).unwrap();
</span>}

</span>struct BearHandler;

</span>impl&lt;T, M: Send + Debug&gt; Handler&lt;T, M&gt; for BearHandler {
</span>    /// A message has been delivered
</span>    fn notify(&amp;mut self, _reactor: &amp;mut EventLoop&lt;T, M&gt;, msg: M) {
</span>        println!(&quot;{:?}&quot;, msg);
</span>    }
</span>}
</span></code></pre>
<p>A <strong>lot</strong> is going on here. Let's take a closer look.</p>
<pre class="z-code"><code><span class="z-text z-plain">EventLoop::&lt;(), String&gt;::new();
</span></code></pre>
<p>This creates a new <code>EventLoop</code>. The Event loop uses <code>T</code> tokens of type <code>()</code>, and channels that consume and pass <code>M: Send</code> of type <code>String</code>. You can use anything that implements <code>Send</code> for messages.</p>
<pre class="z-code"><code><span class="z-text z-plain">event_loop.channel();
</span></code></pre>
<p>This gives us a channel to send <code>String</code>s. When we <code>send()</code> later our <code>BearHandler</code> wakes up and invokes <code>notify</code>.</p>
<p>From there, <code>notify</code> prints out the message. In a real application, this is where your business logic would be to determine what to do with the message.</p>
<h2 id="getting-a-handle-r">Getting a Handle(r)</h2>
<p>A Handler can implement some or all of the following functions:</p>
<pre class="z-code"><code><span class="z-text z-plain">pub trait Handler&lt;T: Token, M: Send&gt; {
</span>    /// A registered IoHandle has available data to read
</span>    fn readable(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, hint: ReadHint, token: T);
</span>    /// A registered IoHandle is available to write to
</span>    fn writable(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, token: T);
</span>    /// A registered timer has expired
</span>    fn timeout(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, token: T);
</span>    /// A message has been delivered
</span>    fn notify(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, msg: M);
</span>    /// A signal has been delivered to the process
</span>    fn signal(&amp;mut self, reactor: &amp;mut EventLoop&lt;T, M&gt;, info: mio::SigInfo);
</span>}
</span></code></pre>
<p>So this is a lot more then just sending some <code>String</code>s around! Did you doubt me?</p>
<p>What's really cool is your <code>Handler</code> can have a data backing since it's just a trait that you can implement yourself! Let's do that now:</p>
<pre class="z-code"><code><span class="z-text z-plain">extern crate mio;
</span>use mio::*;

</span>fn main() {
</span>    // Create an event loop
</span>    let mut event_loop = EventLoop::&lt;(), u64&gt;::new().unwrap();
</span>    let sender = event_loop.channel();
</span>    for i in 0.. 5 {
</span>        sender.send(i).unwrap();
</span>    }
</span>    // Start it
</span>    event_loop.run(&amp;mut BearHandler(0)).unwrap();
</span>}

</span>struct BearHandler(u64);

</span>impl&lt;T&gt; Handler&lt;T, u64&gt; for BearHandler {
</span>    fn notify(&amp;mut self, _reactor: &amp;mut EventLoop&lt;T, u64&gt;, msg: u64) {
</span>        self.0 += msg;
</span>        println!(&quot;Message: {}, Total: {}&quot;, msg, self.0);
</span>    }
</span>}
</span></code></pre>
<p>Output:</p>
<pre class="z-code"><code><span class="z-text z-plain">Message: 0, Total: 0
</span>Message: 1, Total: 1
</span>Message: 2, Total: 3
</span>Message: 3, Total: 6
</span>Message: 4, Total: 10
</span></code></pre>
<p>In this case, our <code>BearHandler</code> was a humble <code>u64</code> tuple which we mutated, but you could easily make this a more complicated <code>struct</code>.</p>
<h2 id="registered-interest">Registered Interest</h2>
<p>Just sending messages isn't particularly interesting, let's wire up some new interests.</p>
<p>Alright, so let's take our humble little <code>BearHandler</code> and build it into a bit of a state mutation game:</p>
<ul>
<li>Each time a timer fire (every 250ms) send a UDP packet to some socket.</li>
<li>Each time that socket gets hit decrement a <code>count</code> by 1.</li>
<li>Each time on the channel increment it by that much.</li>
</ul>
<p>First, we'll modify the <code>BearHandler</code> to reflect these changes. First, we'll make it a proper <code>struct</code> and let it store a pair of sockets as well as it's <code>count</code>.</p>
<p>Second, we'll implement the <code>readable</code>, <code>timeout</code>, and <code>notify</code>. Note in the <code>readable</code> we take care to drain the socket. Also, note how the <code>timeout</code> doesn't need to reset itself, we can clear it with <a rel="noopener" target="_blank" href="https://carllerche.github.io/mio/mio/struct.EventLoop.html#method.clear_timeout"><code>clear_timeout</code></a> if we want.</p>
<pre class="z-code"><code><span class="z-text z-plain">impl Handler&lt;Token, u64&gt; for BearHandler {
</span>    fn readable(&amp;mut self, _reactor: &amp;mut EventLoop&lt;Token, u64&gt;, _token: Token, _hint: ReadHint) {
</span>        let mut buffer = buf::RingBuf::new(1024);
</span>        // Drain socket, otherwise infinite loop!
</span>        net::TryRecv::recv_from(&amp;self.listener, &amp;mut buffer.writer()).unwrap();
</span>        self.count -= 1;
</span>        println!(&quot;Decremented, Total: {}&quot;, self.count);
</span>    }
</span>    fn timeout(&amp;mut self, reactor: &amp;mut EventLoop&lt;Token, u64&gt;, _token: Token) {
</span>        self.sender.send_to(&amp;[0], &quot;127.0.0.1:12345&quot;).unwrap();
</span>        // Reset
</span>        reactor.timeout(TIMEOUT, Duration::milliseconds(250)).unwrap();
</span>        println!(&quot;Timeout&quot;);
</span>    }

</span>    fn notify(&amp;mut self, _reactor: &amp;mut EventLoop&lt;Token, u64&gt;, msg: u64) {
</span>        self.count += msg;
</span>        println!(&quot;Increment by: {}, Total: {}&quot;, msg, self.count);
</span>    }
</span>}
</span></code></pre>
<p>Next, registering the various events, we'll use some of MIO's <code>mio::net</code> items:</p>
<pre class="z-code"><code><span class="z-text z-plain">const LISTENER: Token = Token(0);
</span>const TIMEOUT:  Token = Token(1);
</span>fn main() {
</span>    // Create an event loop
</span>    let mut event_loop = EventLoop::&lt;Token, u64&gt;::new().unwrap();
</span>    // Register Interest
</span>    let listener = UdpSocket::bind(&quot;127.0.0.1:12345&quot;).unwrap();
</span>    event_loop.register(&amp;listener, LISTENER).unwrap(); // Token lets us distinguish.
</span>    // Increments
</span>    let incrementer = event_loop.channel();
</span>    for i in 0.. 5 {
</span>        incrementer.send(i).unwrap();
</span>    }
</span>    // Decrements
</span>    event_loop.timeout(TIMEOUT, Duration::milliseconds(250)).unwrap();
</span>    // Start it
</span>    let sender = UdpSocket::bind(&quot;127.0.0.1:12346&quot;).unwrap();
</span>    event_loop.run(&amp;mut BearHandler {
</span>        count: 0,
</span>        listener: listener,
</span>        sender: sender
</span>    }).unwrap();
</span>}
</span></code></pre>
<p>Output:</p>
<pre class="z-code"><code><span class="z-text z-plain">Increment by: 0, Total: 0
</span>Increment by: 1, Total: 1
</span>Increment by: 2, Total: 3
</span>Increment by: 3, Total: 6
</span>Increment by: 4, Total: 10
</span>Timeout
</span>Decremented, Total: 9
</span>Timeout
</span>Decremented, Total: 8
</span>Timeout
</span>Decremented, Total: 7
</span>Timeout
</span>Decremented, Total: 6
</span>Timeout
</span>Decremented, Total: 5
</span>Timeout
</span>Decremented, Total: 4
</span>Timeout
</span>Decremented, Total: 3
</span>Timeout
</span>Decremented, Total: 2
</span>Timeout
</span>Decremented, Total: 1
</span>Timeout
</span>Decremented, Total: 0
</span></code></pre>
<blockquote>
<p>By the way, in our examples MIO will take over the main thread and block. In a normal application you'll want to kick it off into a new thread when you <code>start()</code> it.</p>
</blockquote>
<h2 id="learn-more">Learn More</h2>
<ul>
<li>I found Wycats' <a rel="noopener" target="_blank" href="https://github.com/wycats/mio-book"><code>mio-book</code></a> repo very useful.</li>
<li>As always, the <a rel="noopener" target="_blank" href="https://carllerche.github.io/mio/mio/index.html">docs</a> were a great help.</li>
<li>This post is <a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/2xvtll/getting_acquainted_with_mio/"><strong>discussed on Reddit</strong></a>.</li>
<li>This post is also <a rel="noopener" target="_blank" href="https://news.ycombinator.com/item?id=9143255"><strong>discussed on Hacker News</strong></a>!</li>
</ul>
<h2 id="help-out">Help Out!</h2>
<p>We're tracking progress on integrating MIO into Raft with <a rel="noopener" target="_blank" href="https://github.com/Hoverbear/raft/issues/6">this issue</a>. Feel free to weigh in or help out!</p>
<blockquote>
<p>A <strong>huge</strong> thanks to <a rel="noopener" target="_blank" href="https://github.com/Hoverbear/raft/commits/master?author=danburkert"><strong>@danburkert</strong></a> for their contributions this week!</p>
</blockquote>

</main>
<footer class="post-footer">
    Connect through &nbsp<a href="mailto:operator@hoverbear.org">operator@hoverbear.org</a>,&nbsp;
    <a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;
    <a rel="me" href="https:&#x2F;&#x2F;hachyderm.io&#x2F;@ana">@ana@hachyderm.io</a> on Mastodon,</a>&nbsp;
    <a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
    or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
</footer>
<pre
        class="artifact"><a id="commit" href="https://github.com/Hoverbear/hoverbear.org/commit/2490e8d6a3321011571419f2ea1b4ef581875ec0
">2490e8d6a3321011571419f2ea1b4ef581875ec0
</a></pre></body>

</html>