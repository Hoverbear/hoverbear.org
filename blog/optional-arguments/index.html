<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>Optional Arguments in Rust
        </title>
        <meta name="description" content="A computer scientist working in open source towards a more hopeful future." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;cbf80a8bf17e211900.jpg"/>
        <meta property='og:image' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;cbf80a8bf17e211900.jpg"/>
        <meta name="twitter:site" content="@a_hoverbear"/>
        <meta name="twitter:creator" content="@a_hoverbear"/>
        
        
            <meta name="twitter:title" content="Optional Arguments in Rust"/>
            <meta property='og:title' content="Optional Arguments in Rust"/>
        

        
            <meta property='og:url' content="https:&#x2F;&#x2F;hoverbear.org&#x2F;blog&#x2F;optional-arguments&#x2F;"/>
        

        
            <meta name="twitter:description" content="When designing an API for your crate one topic which can come is how to handle optional arguments. Let&#x27;s explore our Options in Rust!
"/>
            <meta property='og:description' content="When designing an API for your crate one topic which can come is how to handle optional arguments. Let&#x27;s explore our Options in Rust!
"/>
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Delius&family=Fira+Code&family=Noto+Sans&display=swap" rel="stylesheet">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    

    <body>
        
    <div id="hero-wrapper">
    <figure class="enriched ">
        <figcaption>Photo&nbsp;- A Hobden; Port Renfrew, BC</figcaption>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;60e40d2b2e87fbce00.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;cbf80a8bf17e211900.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;b3daf90e98e00a5000.jpg"
              alt="Photo" />
    </figure>
</div>

    <header>
    <div class="content">
        <h1 id="main-title"><a id="main-link" href="https:&#x2F;&#x2F;hoverbear.org">
            Optional Arguments in Rust
        </a></h1>

        <nav id="tree"><ul><li>
            <a href="https://hoverbear.org/about/">
                Ana, Hoverbear üêª
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/consulting/">
                Consulting Services
            </a>&nbsp;
        </li><li>
            <a href="https://hoverbear.org/blog/">
                Articles
            </a>&nbsp;
        </li></ul><ul></ul><ul></ul>
</nav>


        <div class="metadata">
            <p class="description">
                    Exploring Rust UX and API design.
                </p>

            <p class="date">
                    Posted on 2018-11-04, around 8 minutes of reading.
                </p>
        </div>
    </div>
</header>

    <main>
        
    <nav id=toc>
        <ol>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#we-don-t-have-splats-or-multiple-implementations">We Don&#x27;t Have Splats or Multiple Implementations</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#just-throw-another-function-at-it">Just Throw Another Function At It!</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#we-ve-got-options">We&#x27;ve got Options</a>
                
                <ol>
                    
                    <li>
                        <a href="https://hoverbear.org/blog/optional-arguments/#aside-why-i-like-impl-trait">Aside: Why I like impl Trait</a>
                    </li>
                    
                </ol>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#a-generic-implementation">A Generic Implementation</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#caveats">Caveats</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#benchmarking">Benchmarking</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/optional-arguments/#what-we-learnt-takeaways">What We Learnt &amp; Takeaways</a>
                
            </li>
            
        </ol>
    </nav>

        <p>When designing an API for your crate one topic which can come is how to handle optional arguments. Let's explore our <code>Option</code>s in Rust!</p>
<span id="continue-reading"></span><h2 id="we-don-t-have-splats-or-multiple-implementations">We Don't Have Splats or Multiple Implementations</h2>
<p>Rust currently does not offer functions with variadic or optional arguments. This means this is not possible:</p>
<pre><code>fn impossible(val: bool) {}
fn impossible(val: bool, other: bool) {}
fn impossible(val: bool, rest: bool...) {}
</code></pre>
<p>Coming from languages such as JS or Ruby, you might miss this functionality. In particular, I found myself often looking for a way to have an optional configuration or value I pass in.</p>
<pre><code>// In the context of an configuration structure for a client:
client.connect(&quot;127.0.0.1&quot;)?;
client.connect(&quot;127.0.0.1&quot;, custom_config)?;
</code></pre>
<blockquote>
<p><strong>Note on scope:</strong> I'm not interested in writing about how to deal with variadic arguments at this time. If you are insatiable about this, try it yourself, consider a macro, reference <code>format!()</code>.</p>
</blockquote>
<h2 id="just-throw-another-function-at-it">Just Throw Another Function At It!</h2>
<p>Since that's not possible, what's a viable alternative?</p>
<p>The most obvious is to have <strong>two functions.</strong> There is nothing technically wrong with that. It's perfectly reasonable, and results in a very acceptable API. There is no tricks, and it's understandable immediately:</p>
<pre><code>fn connect(addr: String) -&gt; Result&lt;Self, io::Error&gt; {
    Self::connect_with_config(addr, Config::default())
}

fn connect_with_config(addr: String, config: Config) -&gt; Result&lt;Self, io::Error&gt; {
    // ...
}
</code></pre>
<p>But this is a very specific example. There are sometimes general cases where this is <strong>not</strong> as reasonable. For example, let's say we have a send message that <strong>usually</strong> takes a payload, but supports no payload (for pings, for example). At this point the technique just looks strange, you either end up with <code>message_with_payload()</code> everywhere, a <code>ping()</code> function, or a <code>message_without_payload()</code> function. Using your imagination you might be able to think of other examples in your own code where you've encountered this.</p>
<h2 id="we-ve-got-options">We've got <code>Option</code>s</h2>
<p>The next logical step, which starts to harness Rust's abstractions, is using an <strong>optional type</strong>.</p>
<pre><code>fn message(addr: String, maybe_payload: Option&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;u64, io::Error&gt; {
    // ...
    if let Some(payload) = maybe_payload {
        // Off you go...
    }
    // ...
}
// Using it:
message(&quot;127.0.0.1&quot;, Some(vec![1,2,3]))?;
message(&quot;127.0.0.1&quot;, None)?;
</code></pre>
<p>This certainly gets the job done! Now we can have one function that can internally handle if the value is provided or not. It does clutter up the API a bit, but it seems now we have these odd feeling <code>Some(_)</code> and <code>None</code> variants loitering around.</p>
<p>We boil the problem down with some generics, to get a better idea of what we're trying to accomplish and to support some microbenchmarks.</p>
<pre><code>fn value_arg&lt;Thing&gt;(thing: Thing) -&gt; Thing {
    thing
}

fn optional_arg&lt;Thing&gt;(thing: Option&lt;Thing&gt;) -&gt; Thing
where Thing: Default {
    thing.unwrap_or(Thing::default())
}
</code></pre>
<p>As you can see, these are deliberately as simple as we can possibly make them while not allowing it to be optimized away, they return their value and allow the bencher to accept their output.</p>
<p>Let's get rid of the <code>Some(_)</code>. We can use <strong>generics</strong> via <code>impl Trait</code>, inline generic, or where clauses.</p>
<h3 id="aside-why-i-like-impl-trait">Aside: Why I like <code>impl Trait</code></h3>
<p>I think it enables a more succinct style, better semantics for some use cases, and helps avoid one particular usability mistake that is easy to make. Consider the following:</p>
<pre><code>fn handles_a_pair_of_stringish&lt;Stringish&gt;(first: Stringish, second: Stringish)
where Stringish: AsRef&lt;str&gt; {
    // ...
}

fn handles_a_pair_of_varying_stringish(first: impl AsRef&lt;str&gt;, second: impl AsRef&lt;str&gt;) {
    // ...
}


#[test]
fn send_stringishes_of_difference_type() {
    handles_a_pair_of_stringish(&quot;foo&quot;.to_string(), &quot;foo&quot;); // This won't compile!
    handles_a_pair_of_varying_stringish(&quot;foo&quot;.to_string(), &quot;foo&quot;);
}
</code></pre>
<p>I think in these situations, <code>impl Trait</code> is an effective choice for readability and flexibility. I do <strong>not</strong> encourage you to use it everywhere, for everything. Strive for readability and understandability, not &quot;slick&quot;/arcane APIs.</p>
<h2 id="a-generic-implementation">A Generic Implementation</h2>
<p>In order to refine this design we can pay attention to some key trait implementations:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#impl-From%3CT%3E"><code>impl&lt;T&gt; Into&lt;Option&lt;T&gt;&gt; for T</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#impl-Default"><code>impl&lt;T&gt; Default for Option&lt;T&gt;</code></a></li>
</ul>
<p>This means we can do the following:</p>
<pre><code>fn optional_arg_with_into&lt;Thing&gt;(
    thing: impl Into&lt;Option&lt;Thing&gt;&gt;
) -&gt; Thing
where Thing: Default {
    thing.into().unwrap_or(Thing::default())
}

#[test]
fn verify_assemptions() {
    optional_arg_with_into(Vec::&lt;u64&gt;::default());
    optional_arg_with_into(vec![1_u64, 2, 3]);
    let out: Vec&lt;u64&gt; = optional_arg_with_into(None::&lt;Vec&lt;u64&gt;&gt;); // Type hinting
}
</code></pre>
<p>In this very limited demo code we need to provide quite a bit of type hinting to the <code>None</code> argument. This is not normally the case for more projects with a non-trivial codebase.</p>
<p>At this point, you're able to leverage a couple basic traits (<code>Default</code> and <code>From</code>) to give your users a more flexible API.</p>
<h2 id="caveats">Caveats</h2>
<p>As you may have noticed in the last example, in the case of very simple code this can get pretty verbose. That's because we're not doing anything with the return/argument values. As your project grows the need for the hinting will disappear, as the compiler will be able to make more inferences about the types of things.</p>
<p>Using this technique can reduce your ability to flexibly accept things that turn into the inner argument. Eg a <code>U</code> where <code>impl From&lt;U&gt; for T</code>. You might need to jump through some hoops. Getting around this the easy way will force your users to do <code>T::from(u)</code> in the argument position when calling. Still, not too bad.</p>
<h2 id="benchmarking">Benchmarking</h2>
<p>Let's make sure that adding this flexibility doesn't have a huge performance impact on our code. I used Criterion and wrote a small suite for our demo code. Since the code is trivial (it basically just converts and converts back), we can explore the cost of just doing this operation. Here is the entire bench code:</p>
<pre><code>#[macro_use(criterion_main, criterion_group)] extern crate criterion;
use criterion::Criterion;

criterion_main!(benches);
criterion_group!(benches, optional_args::group);

mod optional_args {
    use criterion::Criterion;

    fn value_arg&lt;Thing&gt;(thing: Thing) -&gt; Thing {
        thing
    }

    fn optional_arg&lt;Thing&gt;(thing: Option&lt;Thing&gt;) -&gt; Thing
    where Thing: Default {
        thing.unwrap_or(Thing::default())
    }

    fn optional_arg_with_into&lt;Thing&gt;(
        thing: impl Into&lt;Option&lt;Thing&gt;&gt;
    ) -&gt; Thing
    where Thing: Default {
        thing.into().unwrap_or(Thing::default())
    }

    pub(crate) fn group(c: &amp;mut Criterion) {
        c.bench_function(&quot;value 1_u64&quot;, |b| b.iter(|| -&gt; u64 {
            let value = value_arg(1_u64);
            value + 1
        }));
        c.bench_function(&quot;optional Some(1_u64)&quot;, |b| b.iter(|| -&gt; u64 {
            let value = optional_arg(Some(1_u64));
            value + 1
        }));
        c.bench_function(&quot;optional_into 1_u64&quot;, |b| b.iter(|| -&gt; u64 {
            let value = optional_arg_with_into(1_u64);
            value + 1
        }));
        c.bench_function(&quot;optional_into Some(1_u64)&quot;, |b| b.iter(|| -&gt; u64 {
            let value: u64 = optional_arg_with_into(Some(1_u64));
            value + 1
        }));
        c.bench_function(&quot;optional_into (u64) None&quot;, |b| b.iter(|| -&gt; u64 {
            let value: u64 = optional_arg_with_into(None);
            value + 1
        }));
        c.bench_function(&quot;optional_into 1_u8.into()&quot;, |b| b.iter(|| -&gt; u64 {
            let value: u64 = optional_arg_with_into(u64::from(1_u8));
            value + 1
        }));
        c.bench_function(&quot;optional_into Vec&lt;u64&gt;::new()&quot;, |b| b.iter(|| -&gt; Vec&lt;u64&gt; {
            let value: Vec&lt;u64&gt; = optional_arg_with_into(Vec::&lt;u64&gt;::new());
            value
        }));
        c.bench_function(&quot;optional_into (Vec&lt;u64&gt;) None&quot;, |b| b.iter(|| -&gt; Vec&lt;u64&gt; {
            let value: Vec&lt;u64&gt; = optional_arg_with_into(None::&lt;Vec&lt;u64&gt;&gt;);
            value
        }));
    }
}
</code></pre>
<p>It's pretty snappy, enough so I'm still not <em>entirely</em> convinced it's not getting optimized out somehow. Computers are sneaky.</p>
<pre><code>value 1_u64             time:   [264.11 ps 264.50 ps 264.97 ps]                        
Found 15 outliers among 100 measurements (15.00%)
  1 (1.00%) low mild
  5 (5.00%) high mild
  9 (9.00%) high severe

optional Some(1_u64)    time:   [263.41 ps 263.86 ps 264.44 ps]                                 
Found 18 outliers among 100 measurements (18.00%)
  3 (3.00%) low mild
  4 (4.00%) high mild
  11 (11.00%) high severe

optional_into 1_u64     time:   [258.67 ps 259.43 ps 260.37 ps]                                
Found 7 outliers among 100 measurements (7.00%)
  3 (3.00%) high mild
  4 (4.00%) high severe

optional_into Some(1_u64)                                                                            
                        time:   [252.95 ps 253.41 ps 253.94 ps]
Found 6 outliers among 100 measurements (6.00%)
  2 (2.00%) high mild
  4 (4.00%) high severe

optional_into (u64) None                                                                            
                        time:   [256.31 ps 256.89 ps 257.70 ps]
Found 12 outliers among 100 measurements (12.00%)
  3 (3.00%) high mild
  9 (9.00%) high severe

optional_into 1_u8.into()                                                                            
                        time:   [255.77 ps 256.33 ps 257.04 ps]
Found 12 outliers among 100 measurements (12.00%)
  1 (1.00%) low mild
  7 (7.00%) high mild
  4 (4.00%) high severe

optional_into Vec&lt;u64&gt;::new()                                                                             
                        time:   [853.18 ps 858.14 ps 863.70 ps]
Found 4 outliers among 100 measurements (4.00%)
  4 (4.00%) high mild

optional_into (Vec&lt;u64&gt;) None                                                                             
                        time:   [830.59 ps 833.04 ps 835.56 ps]
</code></pre>
<h1 id="what-we-learnt-takeaways">What We Learnt &amp; Takeaways</h1>
<p>We learnt there are many options when it comes to API design with Rust. During our exploration we noted that choosing to declare our functions semantically, and/or enabling a more flexible API doesn't have to cost much.</p>
<p>If you're interested in learning more about enabling flexible APIs in Rust, I'd reccomend exploring the <a href="https://rust-lang-nursery.github.io/api-guidelines/flexibility.html">Guidelines</a>. I'd also reccomend exploring the <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">Builder Pattern</a>, since it's generally more well used in Rust.</p>
<p>Thanks for reading! Hope to use your lovely code soon. üòâ</p>
<blockquote>
<p><strong>P.S.</strong> If you are looking for a <strong>senior level</strong> position, are passionate about this topic, and have experience with distributed systems, safety critical systems, data structures, networking, and chaos engineering please <a href="https://hoverbear.org/blog/optional-arguments/operator@hoverbear.org">email me</a>. We can chat about the possibility of working on my team at <a href="http://pingcap.com/">PingCAP</a> doing open source ecosystem work for <a href="https://github.com/tikv/tikv">TiKV</a> and its dependencies. In the future you would get to take on mentoring new juniors, open source contributors, and community members at large. Globally remote friendly, competitive salaries, travel coverage for speaking, very minority friendly (location, race, sexuality, gender, etc).</p>
</blockquote>

    </main>
    <footer class="post-footer">
    Connect through &nbsp<a href="mailto:operator@hoverbear.org">operator@hoverbear.org</a>,&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
    or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
</footer>
<pre class="artifact"><a id="commit" href="https://github.com/Hoverbear/hoverbear.org/commit/da034546dcea5f4d6d55dd32b6410d8a8e93e7ef
">da034546dcea5f4d6d55dd32b6410d8a8e93e7ef
</a></pre>
    </body>

</html>
