<!DOCTYPE html>
<html>
    <head>
        <!-- Fun compatability things -->
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- (1) Optimize for mobile versions: http://goo.gl/EOpFl -->
        <meta http-equiv="X-UA-Compatible" content="IE=edge">                  <!-- (1) force latest IE rendering engine: bit.ly/1c8EiC9 -->
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <link rel="shortcut icon" href="https:&#x2F;&#x2F;hoverbear.org/images/favicon.ico">
    
        <!-- Information about this site -->
        <title>New Roots part 5, Erecting Container Infrastructure</title>
        <meta name="description" content="A computer scientist working in open source towards a more hopeful future." />
    
        <!-- Various Twitter related content. -->
        <meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;e6bd6e8057e9432100.jpg">
        <meta name="twitter:site" content="@a_hoverbear">
        <meta name="twitter:creator" content="@a_hoverbear">
        
            <meta name="twitter:title" content="New Roots part 5, Erecting Container Infrastructure">
        
        
            <meta name="twitter:description" content="This is the fifth part of an ongoing series on configuring a new server. In our last post we discussed and configured some basic tools. For all intensive purposes, our &#x27;root&#x27; system is complete. What we&#x27;ll be doing now is building the infrastructure to run containers the way we want to.
Before we get around to setting things up, let&#x27;s describe the what we&#x27;re up to.
">
        
    
        <!-- Talk about the homepage and the rss feed. -->
        <link rel="canonical" href="https:&#x2F;&#x2F;hoverbear.org">
        <link rel="alternate" type="application/rss+xml" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">
    
        <!-- Stylesheets are fun -->
        <link rel="stylesheet" href="https:&#x2F;&#x2F;hoverbear.org/font/fira_code/fira_code.css">
        <link rel="stylesheet" href="https:&#x2F;&#x2F;hoverbear.org/font/fira/fira.css">
        <link rel="stylesheet" type="text/css" media="screen" href="https:&#x2F;&#x2F;hoverbear.org/main.css" />
    
        <!-- Katex -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
        <!-- To automatically render math in text elements, include the auto-render extension: -->
        <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    </head>
    

    <body>
        <header><div id="hero-wrapper">
        <figure class="enriched ">
        <figcaption>Photo&nbsp;- Ethan Dow</figcaption>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;833c2916e79c91aa00.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;e6bd6e8057e9432100.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;7e8b8296ee9292f500.jpg"
              alt="Photo" />
    </figure>
    </div>
    <div class="hero-wrapper-content">

        <h1><a href="https:&#x2F;&#x2F;hoverbear.org">New Roots part 5, Erecting Container Infrastructure</a></h1>

        <nav id="pages">
            <ul><li>
                        <a href="/about">
                            About
                        </a>&nbsp;</li><li>
                        <a href="/blog">
                            Blog
                        </a>&nbsp;</li><li>
                        <a href="/consulting">
                            Consulting
                        </a>&nbsp;</li><li>
                        <a href="/">
                            Home
                        </a>&nbsp;</li></ul>
        </nav>

        <div class="metadata">
            <p class="description">
                    A computer scientist working in open source towards a more hopeful future.
                </p>

            <p class="date">
                    Posted on 2016-05-10, around 18 minutes of reading.
                </p>
        </div>
    </div>
</header>
      

        <main>
            <article>
                
    <nav id=toc>
        <ol>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#our-first-container">Our First Container</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#orcestration">Orcestration</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#fixing-an-anti-feature">Fixing an Anti-Feature</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#inter-container-networking">Inter-Container Networking</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#the-upgrade-problem">The Upgrade Problem</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#the-web-proxy">The Web Proxy</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#rest-and-test">Rest and Test</a>
                
            </li>
            
            <li>
                <a href="https://hoverbear.org/blog/new-roots-5/#system-evolution">System Evolution</a>
                
            </li>
            
        </ol>
    </nav>

                
    <p>This is the fifth part of an ongoing series on configuring a new server. In our <a href="/2016/05/09/new-roots-4/">last post</a> we discussed and configured some basic tools. For all intensive purposes, our 'root' system is complete. What we'll be doing now is building the infrastructure to run containers the way we want to.</p>
<p>Before we get around to setting things up, let's describe the what we're up to.</p>
<span id="continue-reading"></span>
<p>Currently, the only external service the server is running is <code>ssh</code>. We'd like our server to host more services. These services are likely to be both internal services like databases, and external services like HTTP/HTTPS hosts. Since the IPv4 space is increasingly crowded we'd like to do all of these things from one IPv4 address too.</p>
<p>There are lots of ways to provide isolation to these services. These include virtual machines through something like <a href="http://xenproject.org/">Xen</a>, containers through something like <a href="https://www.docker.com/">Docker</a>, or even just chroots. Isolation isn't just for security, it's one way to help increase your security <em>somewhat</em> but it isn't a silver bullet. Light solutions like containers have very little overhead though so the benefits tend to outweigh the costs.</p>
<p>We'll use containers, because they're entertaining and fun to use. This is a laboratory, remember? We're suposed to have fun and play with new things.</p>
<h2 id="our-first-container">Our First Container</h2>
<p>We'll be using <code>machinectl</code> to work with our containers. You may already know Docker, CoreOS's <code>rkt</code>, or <code>lxc</code>, and you're more than welcome to use any of those. The important thing is to only use <strong>one</strong> on this machine. You don't want to be managing multiple container providers. Good news is they're all pretty much compatible with one another, so if you use <code>machinectl</code> you can still use Docker images.</p>
<p>To get started with our first container, we first need to construct one. We'll make a scratch directory and put it in there. We'll tell <code>pacstrap</code>, which came as part of <code>arch-install-scripts</code>, to ignore anything that's likely unnecessary in a container.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mkdir -p ~</span><span style="color:#c0c5ce;">/scratch/
</span><span style="color:#96b5b4;">echo </span><span style="color:#bf616a;">-e </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">n\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\nn\n\n</span><span style="color:#c0c5ce;">&quot; | </span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> pacstrap</span><span style="color:#bf616a;"> -i -c -d ~</span><span style="color:#c0c5ce;">/scratch/ base</span><span style="color:#bf616a;"> --ignore</span><span style="color:#c0c5ce;"> linux,linux-firmware,cryptsetup,jfsutils,lvm2,nano,netctl,reiserfsprogs,vi,xfsprogs,mdadm,device-mapper,licenses,man-pages,pcmciautils
</span></code></pre>
<p>This should give you an installed package size of under 400MB. That's pretty decent. We could probably go smaller but it doesn't really matter. We don't need to worry about setting up things like <code>iptables</code> since it's already protected via the host, and we don't need to have things like <code>vi</code> because we'll do our editing from outside of the container. We don't need things like <code>linux</code> because we're using the host kernel.</p>
<p>Take a look in <code>~/scratch</code> and you should see what appears to be a base Arch install like we had before. We're going to use <code>chroot</code> to enable some services by default, finally we're going to import it into <code>machinectl</code>:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#96b5b4;">cd </span><span style="color:#bf616a;">~</span><span style="color:#c0c5ce;">/scratch
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> chroot .</span><span style="color:#a3be8c;">
    systemctl enable systemd-networkd
    systemctl enable systemd-resolved
    rm /etc/resolv.conf
    ln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf
    sed -i -e &#39;s/hosts: files dns myhostname/hosts: files mymachines resolve myhostname/g&#39; /etc/nsswitch.conf
</span><span style="color:#b48ead;">EOF
</span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> tar</span><span style="color:#bf616a;"> --create --preserve-permissions --gzip </span><span style="color:#c0c5ce;">* | </span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl import-tar</span><span style="color:#bf616a;"> --read-only</span><span style="color:#c0c5ce;"> - base
</span></code></pre>
<p>After a second, this command will be done and we'll have our first image. <code>machinectl list-images</code> shows this:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">NAME TYPE      RO  USAGE  CREATED                     MODIFIED
base subvolume yes 277.6M Wed 2016-05-11 15:52:43 PDT n/a     

1 images listed.
</span></code></pre>
<p>We can test out the image with <code>machinectl start base</code>. If you get an &quot;Operation not supported&quot; error here it's because you updated your kernel and haven't restarted. Later we'll talk about <a href="https://wiki.archlinux.org/index.php/kexec"><code>kexec</code></a> to help with this problem.</p>
<p>You can get a shell into the container with <code>machinectl shell base</code>. You'll probably notice there is no network connection. That's because our firewall is blocking us! You can check this by observing <code>iptables -nvL</code> and watching the packet counts go up on the <code>icmp-port-unreachable</code> filter.</p>
<p>Editing our <code>/etc/iptables/iptables.rules</code> we can add the green lines:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;"> # Accept anything from the local loopback.
 --append INPUT --in-interface lo --jump ACCEPT
</span><span style="color:#a3be8c;">+# Accept anything originating from a container.
+--append INPUT --in-interface ve-+ --jump ACCEPT
+--append FORWARD --in-interface ve-+ --jump ACCEPT
</span></code></pre>
<p>This rule will make it so any communications coming from our container adapters will be permitted accepted. Now reload the firewall with <code>systemctl restart iptables</code>.</p>
<p>Returning to your container with <code>machinectl reboot base</code> then <code>machinectl shell base</code>, from here you should be able to run <code>ping hoverbear.org</code> and <code>ping silicon</code> if <code>silicon</code> is your machine's hostname like mine.</p>
<p>You can check over your work by running <code>btrfs subvolume list /</code> and verifying that there is a <code>var/lib/machines/base</code> subvolume, then running <code>machinectl list-images --all</code> and verifying there is a <code>base</code> image.</p>
<p>From here you can create writable clones of the image with <code>machinectl clone base $NAME</code>, then <code>start</code> them, <code>shell</code> into them, and ultimately <code>poweroff</code> them. When you're ready to get rid of them entirely you can <code>remove</code> them.</p>
<p>Later on you can upgrade your <code>base</code> image in a similar way.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl clone base upgrade
</span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl start upgrade
</span></code></pre>
<p>After a moment to start you can issue the upgrade command.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl shell upgrade /bin/pacman -- -Syu
</span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl poweroff upgrade
</span></code></pre>
<p>After another moment you can finish up.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl remove base
</span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl read-only upgrade
</span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl rename upgrade base
</span></code></pre><h2 id="orcestration">Orcestration</h2>
<p>At this point you might have identified a potential problem coming up. <em>How do we create and maintain all these gosh darn containers?</em> Well, that's a <strong>great</strong> question! We're going to try using <a href="https://docs.puppet.com/puppet/">Puppet</a>!</p>
<p>This is a very different strategy compared to that taken by Docker. Docker uses declarative <code>Dockerfile</code>s to build images, then you upgrade by either replacing the current running container, or executing commands via the <code>run</code> subcommand. With <code>puppet</code> we'll be able to easily execute pre-defined provisioning scripts and maintain our running containers.</p>
<p>Also, I want to learn Puppet, so this is a great excuse. You can review the Puppet docs as well as <a href="https://www.digitalocean.com/community/tutorial_series/how-to-use-puppet-to-manage-your-servers-2">this guide by Digital Ocean</a>. Our plan is a bit different than those.</p>
<p>Let's start by creating a <code>puppet</code> container from our base.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">machinectl</span><span style="color:#c0c5ce;"> clone base puppet
</span></code></pre>
<p>Since we're basing our <code>puppet</code> image on our <code>base</code> Arch image we can have them share repository caches. Neat! Next we'll create a <code>environments</code> subvolume on our BTRFS volume so we can mount it into the <code>puppet</code> image. This will help us not accidently delete things. We're 'in' a subvolume already so we need to actually mount the true root for this.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /dev/sda /mnt/
</span><span style="color:#bf616a;">btrfs</span><span style="color:#c0c5ce;"> subvolume create /mnt/config/puppet
</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">/dev/sda    /config/puppet             btrfs   subvol=config/puppet,rw,relatime,ssd,space_cache,compress=lzo          0   0</span><span style="color:#c0c5ce;">&quot; &gt;&gt; /etc/fstab
</span><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /config/puppet
</span><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /config/puppet
</span></code></pre>
<p>We'll create <code>/etc/systemd/nspawn/puppet.nspawn</code> which is the container specific configuration.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /etc/systemd/nspawn/
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /etc/systemd/nspawn/puppet.nspawn</span><span style="color:#a3be8c;">
[Files]
# Official packages are signed and verified before install
Bind=/var/cache/pacman
# abs packages are not.
BindReadOnly=/var/cache/abs
# Bind in our puppet configuration.
Bind=/config/puppet:/etc/puppetlabs
</span><span style="color:#b48ead;">EOF
</span></code></pre>
<blockquote>
<p>See anti-feature note in next section.</p>
</blockquote>
<p>Now we can start the machine and hop inside.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl start puppet
</span><span style="color:#bf616a;">sudo</span><span style="color:#c0c5ce;"> machinectl shell puppet
</span></code></pre>
<p>Inside of this container we can start seting up Puppet! First we'll install it:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">pacman -Syu</span><span style="color:#c0c5ce;"> puppet</span><span style="color:#bf616a;"> --noconfirm
</span></code></pre>
<p>Before we start making manifests we need to get the server working though! In order to do this we need to edit our configuration file at <code>/etc/puppetlabs/puppet/puppet.conf</code>.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#65737e;"># In puppet container
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt;&gt; /etc/puppetlabs/puppet/puppet.conf</span><span style="color:#a3be8c;">
[main]
certname = puppet
bindaddress = ::
autosign = true
environment = production
runinterval = 1h
strict_variables = true
</span><span style="color:#b48ead;">EOF
</span></code></pre>
<p>Next we'll make a simple <code>.service</code> file for <code>puppet master</code> since it doesn't come with one by default. You can run <code>systemctl cat puppet</code> to see the configuration of <code>puppet agent</code>. We'll basically just copy this.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /etc/systemd/system/puppetmaster.service</span><span style="color:#a3be8c;">
[Unit]
Description=Puppet master
Wants=basic.target
After=basic.target network.target

[Service]
EnvironmentFile=-/etc/sysconfig/puppetmaster
EnvironmentFile=-/etc/sysconfig/puppet
EnvironmentFile=-/etc/default/puppet
ExecStart=/usr/bin/puppet master </span><span style="color:#c0c5ce;">$</span><span style="color:#bf616a;">PUPPET_EXTRA_OPTS</span><span style="color:#a3be8c;"> --no-daemonize
ExecReload=/bin/kill -HUP </span><span style="color:#c0c5ce;">$</span><span style="color:#bf616a;">MAINPID</span><span style="color:#a3be8c;">
KillMode=process

[Install]
WantedBy=multi-user.target
</span><span style="color:#b48ead;">EOF
</span></code></pre>
<p>Now you can start it with <code>systemctl start puppetmaster</code>. At this point let's consider that our <code>puppet</code> container should probably be managed by Puppet as well! Let's do that to learn how to use Puppet, then we'll figure out networking.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /etc/puppetlabs/code/environments/production/manifests/
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /etc/puppetlabs/code/environments/production/manifests/main.pp</span><span style="color:#a3be8c;">
node puppet,test {
    file { &#39;puppet-test&#39;:
        path    =&gt; &#39;/puppet-test&#39;,
        ensure  =&gt; file,
        content =&gt; &quot;Hello. Hallo.&quot;,
        owner   =&gt; &#39;root&#39;,
        mode    =&gt; &#39;0644&#39;,
    }
}
</span><span style="color:#b48ead;">EOF
</span></code></pre>
<p>Now you can run <code>systemctl start puppet</code> (this is the agent) and you might see that <code>/puppet-test</code> now exists. If not you might either need to wait a moment or restart <code>puppet</code>. This is due to the syncing behaivor which we can tame later.</p>
<p>Finally run <code>systemctl enable puppet</code> and <code>systemctl enable puppetmaster</code>. Remember that you can edit this configuration from outside the container by editing the things in <code>/puppet</code> on the our root.</p>
<p>All we need to do now is add Puppet to our <code>base</code>. First make it writable with <code>machinectl read-only base false</code>, start it, then shell in with <code>machinectl shell base</code>.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">pacman -Syu</span><span style="color:#c0c5ce;"> puppet</span><span style="color:#bf616a;"> --noconfirm
systemctl</span><span style="color:#c0c5ce;"> enable puppet
</span></code></pre>
<p>Then <code>poweroff</code> it and mark it read only again with <code>machinectl read-only base true</code>. Now when we clone it the new containers will automatically run puppet.</p>
<h2 id="fixing-an-anti-feature">Fixing an Anti-Feature</h2>
<p>A note, if you <code>machinectl remove $MACHINE</code> systemd will, in rather user hostile manner, delete your <code>/etc/systemd/nspawn/$MACHINE.nspawn</code> file, with no output, <a href="https://www.freedesktop.org/software/systemd/man/machinectl.html#remove%20NAME...">no warning</a>, or flag to disable this anti-feature.</p>
<p>So let's fix it! In fact, we can make our <code>/etc/sytemd/network/</code> and <code>/etc/systemd/nspawn</code> folders both subvolumes for safe keeping. With <code>config/puppetlabs/</code> also as subvolume our primary container configuration will be stored safely in subvolumes.</p>
<p>Reviewing <code>btrfs subvolume list /</code> you may notice that our machines have been creating subvolumes as they go. This is great. We can use these for snapshots later. We'll create a <code>config/network</code> and <code>config/nspawn</code>. Recall that we're 'in' a subvolume already so we need to actually mount the true root for this again.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /dev/sda /mnt/
</span><span style="color:#bf616a;">btrfs</span><span style="color:#c0c5ce;"> subvolume create /mnt/config/network
</span><span style="color:#bf616a;">btrfs</span><span style="color:#c0c5ce;"> subvolume create /mnt/config/nspawn
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt;&gt; /etc/fstab</span><span style="color:#a3be8c;">
/dev/sda    /config/nspawn      btrfs   subvol=config/nspawn,rw,relatime,ssd,space_cache,compress=lzo   0   0
/dev/sda    /config/network     btrfs   subvol=config/network,rw,relatime,ssd,space_cache,compress=lzo   0   0
# Read only so nothing gets deleted.
/dev/sda    /etc/systemd/nspawn btrfs   subvol=config/nspawn,ro,relatime,ssd,space_cache,compress=lzo   0   0
/dev/sda    /etc/systemd/network btrfs   subvol=config/network,ro,relatime,ssd,space_cache,compress=lzo   0   0
</span><span style="color:#b48ead;">EOF
</span><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /config/nspawn
</span><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /config/network
</span><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /config/nspawn
</span><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /config/network
</span><span style="color:#65737e;"># Remount the folders.
</span><span style="color:#c0c5ce;">cp</span><span style="color:#bf616a;"> -r</span><span style="color:#c0c5ce;"> /etc/systemd/nspawn/* /config/nspawn/ &amp;&amp; </span><span style="color:#bf616a;">rm -r</span><span style="color:#c0c5ce;"> /etc/systemd/nspawn/*
</span><span style="color:#bf616a;">cp -r</span><span style="color:#c0c5ce;"> /etc/systemd/network/* /config/network/ &amp;&amp; </span><span style="color:#bf616a;">rm -r</span><span style="color:#c0c5ce;"> /etc/systemd/network/*
</span><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /etc/systemd/network
</span><span style="color:#bf616a;">mount</span><span style="color:#c0c5ce;"> /etc/systemd/nspawn
</span></code></pre>
<p>Great. Try <code>touch /etc/systemd/nspawn/web.puppet</code>, you can't! Instead, you can <code>touch /config/nspawn/web.puppet</code>.</p>
<h2 id="inter-container-networking">Inter-Container Networking</h2>
<p>Right now if you start up <code>base</code> and try to <code>ping puppet</code> from it things it won't work. You can observe the differences in their IP addresses. Mine were <code>169.254.143.177/16</code> and <code>169.254.221.43/16</code> which are on different subnets. We need some what to bring them together.</p>
<p>I tried a few ways of doing this (actually spent 6 days trying different ideas) and ended up on this because it's the simplest and seems easiest to understand.</p>
<p>First we'll go ahead and create a bridge. A bridge will let us join all the containers together on a single network so they can resolve each others names. For now this is sufficient, though there is some documentation suggestion <a href="http://doger.io/#networking">VLANs</a> can be used to improve this system. Perhaps we'll explore that later.</p>
<p>On our 'root' host:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /config/network/br-internal.netdev</span><span style="color:#a3be8c;">
[NetDev]
Name=br-internal
Kind=bridge
Description=The internal network bridge.
EOF</span><span style="background-color:#bf616a;color:#2b303b;">
</span><span style="color:#a3be8c;">
</span><span style="color:#c0c5ce;">cat &lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /config/network/br-internal.network</span><span style="color:#a3be8c;">
[Match]
Name=br-internal

[Network]
Description=The internal network bridge.
DHCP=yes
EOF</span><span style="background-color:#bf616a;color:#2b303b;">
</span><span style="color:#a3be8c;">
</span><span style="color:#c0c5ce;">machinectl read-only base false
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /var/lib/machines/base/etc/systemd/network/internal.network</span><span style="color:#a3be8c;">
[Match]
Name=int-*

[Network]
Description=The internal network connecting containers.
DHCP=yes
</span><span style="color:#b48ead;">EOF
</span><span style="color:#bf616a;">machinectl</span><span style="color:#c0c5ce;"> read-only base true
</span></code></pre>
<p>Then run <code>systemctl edit systemd-nspawn@</code> and enter the following:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">[Service]
</span><span style="color:#65737e;"># Set up.
</span><span style="color:#bf616a;">ExecStartPre</span><span style="color:#c0c5ce;">=/bin/sh</span><span style="color:#bf616a;"> -c </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">ip link add int-</span><span style="color:#c0c5ce;">$</span><span style="color:#a3be8c;">(</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">%</span><span style="color:#bf616a;">I </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">cut -c</span><span style="color:#a3be8c;"> 1-11) type veth peer name con-</span><span style="color:#c0c5ce;">$</span><span style="color:#a3be8c;">(</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">%</span><span style="color:#bf616a;">I </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">cut -c</span><span style="color:#a3be8c;"> 1-11)</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#bf616a;">ExecStartPre</span><span style="color:#c0c5ce;">=</span><span style="color:#a3be8c;">/bin/sh </span><span style="color:#bf616a;">-c </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">ip link set con-</span><span style="color:#c0c5ce;">$</span><span style="color:#a3be8c;">(</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">%</span><span style="color:#bf616a;">I </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">cut -c</span><span style="color:#a3be8c;"> 1-11) master br-internal</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#bf616a;">ExecStartPre</span><span style="color:#c0c5ce;">=</span><span style="color:#a3be8c;">/bin/sh </span><span style="color:#bf616a;">-c </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">ip link set con-</span><span style="color:#c0c5ce;">$</span><span style="color:#a3be8c;">(</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">%</span><span style="color:#bf616a;">I </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">cut -c</span><span style="color:#a3be8c;"> 1-11) up</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#65737e;"># Do work
</span><span style="color:#c0c5ce;">ExecStart=
</span><span style="color:#bf616a;">ExecStart</span><span style="color:#c0c5ce;">=</span><span style="color:#a3be8c;">/bin/sh </span><span style="color:#bf616a;">-c </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">systemd-nspawn --quiet --keep-unit --boot --link-journal=try-guest --network-veth --network-interface=int-</span><span style="color:#c0c5ce;">$</span><span style="color:#a3be8c;">(</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">%</span><span style="color:#bf616a;">I </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">cut -c</span><span style="color:#a3be8c;"> 1-11) --settings=override --machine=%I</span><span style="color:#c0c5ce;">&quot;
</span><span style="color:#65737e;"># Tear down.
</span><span style="color:#c0c5ce;">ExecStopPost=-/bin/sh</span><span style="color:#bf616a;"> -c </span><span style="color:#c0c5ce;">&quot;</span><span style="color:#a3be8c;">ip link delete con-</span><span style="color:#c0c5ce;">$</span><span style="color:#a3be8c;">(</span><span style="color:#96b5b4;">echo </span><span style="color:#c0c5ce;">%</span><span style="color:#bf616a;">I </span><span style="color:#c0c5ce;">| </span><span style="color:#bf616a;">cut -c</span><span style="color:#a3be8c;"> 1-11)</span><span style="color:#c0c5ce;">&quot;
</span></code></pre>
<p>Try issuing <code>machinectl clone base test</code> <code>machinectl poweroff test puppet</code>, <code>machinectl start test puppet</code>, then try running <code>machinectl shell test</code> and see if you can <code>ping puppet</code>. Finally make sure you can <code>ping hoverbear.org</code>. If all is well then we've had great success.</p>
<p>At this point if you start up both the <code>puppet</code> and <code>test</code> container you should find a <code>/puppet-test</code> file on both. You can verify things with <code>systemctl status puppet</code>.</p>
<h2 id="the-upgrade-problem">The Upgrade Problem</h2>
<p>Earlier you made have already run into this problem, but if we run <code>pacman -Syu</code> and the <code>linux</code> package on the 'root' container gets upgraded this can cause some problems for us in the long haul. This may manifest as &quot;Operation Not Permitted&quot; errors when using tools like <code>ip</code>, this is because the kernel is trying to access modules on the file system which no longer exist.</p>
<p>We can use a tool called <code>kexec</code> to quickly (and uncleanly) switch to the new kernel. On my server this takes about a third of the time compared to actually rebooting. It's important to note that this doesn't <em>replace</em> a reboot though, as it doesn't make efforts to clean up anything. Things may go funky, and you may still need to reboot.</p>
<p>We'll build a systemd unit for this then enable it like so:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">pacman -S</span><span style="color:#c0c5ce;"> kexec-tools
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /etc/systemd/system/kexec-load@.service</span><span style="color:#a3be8c;">
[Unit]
Description=Load %i as the kernel.
Documentation=man:kexec(8)
DefaultDependencies=no
Before=shutdown.target umount.target final.target

[Service]
Type=oneshot
ExecStart=/usr/bin/kexec -l /boot/vmlinuz-%i --initrd=/boot/initramfs-%i.img --reuse-cmdline

[Install]
WantedBy=kexec.target
</span><span style="color:#b48ead;">EOF
</span><span style="color:#bf616a;">systemctl</span><span style="color:#c0c5ce;"> enable kexec-load@linux
</span></code></pre>
<p>Now you can load into the newest kernel with <code>systemctl kexec</code> when you decide it's time. I'd suggest testing it now before moving on so you know it works! This also works great as a soft reboot.</p>
<h2 id="the-web-proxy">The Web Proxy</h2>
<p>Since we know we'd like to host be able to host multiple web services we'll need to set up a <em>proxy</em> to handle port 80, the default socket for <code>httpd</code>. Since only one program can bind to a given port at a time, its job will be to inspect the incoming traffic to observe the <em>Server Name Indentification</em>, or <em>SNI</em>, then route it to the appropriate container. By default this will be the <code>web-$VARIABLE</code> container, where the request is <code>$VARIABLE.$DOMAIN.$TLD</code>. We'll call the proxy itself <code>web</code>.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">[network: example.hoverbear.org]-&gt;[web]-&gt;[web-example]
</span></code></pre>
<p>Later we'll follow a similar scheme for <code>db</code>, <code>usr</code>, <code>box</code>, etc. You can use whichever scheme you'd like, or change later, just <strong>be consistent</strong>.</p>
<p>We'll start by editing our puppet configuration to define what this host should look like. Since we have the puppet configuration subvolume mounted on <code>/puppet</code> on our host we can just edit it from there.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /config/puppet/code/modules/web/files/
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /config/puppet/code/modules/web/files/haproxy.cfg</span><span style="color:#a3be8c;">
global
    user haproxy
    group haproxy
    daemon

defaults
    timeout client 10s
    timeout server 10s
    timeout connect 10s

frontend unsecured
    bind *:80
    mode http
    log /dev/log local0 info
    # Wait for delay on HELO
    tcp-request inspect-delay 5s
    # Redirect
    redirect scheme https code 301

frontend secured
    bind *:443
    mode tcp
    option tcplog
    log /dev/log local0 info
    # Wait for delay on HELO
    tcp-request inspect-delay 5s
    tcp-request content accept if { req.ssl_hello_type 1 }
    # Figure out which backend (= container) to use
    use_backend silicon_host if { req_ssl_sni -i silicon.hoverbear.org }

backend silicon_host
    mode tcp
    option tcplog
    log /dev/log local0 info
    # Pass it along
    option ssl-hello-chk
    server web-silicon web-silicon:443 check
</span><span style="color:#b48ead;">EOF
</span><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /config/puppet/code/environments/production/manifests/
</span><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /config/puppet/code/environments/production/manifests/main.pp</span><span style="color:#a3be8c;">
node web {
    file { &#39;haproxy.cfg&#39;:
        path    =&gt; &#39;/etc/haproxy/haproxy.cfg&#39;,
        ensure  =&gt; file,
        source =&gt; &#39;puppet:///modules/web/haproxy.cfg&#39;,
        owner   =&gt; &#39;root&#39;,
        mode    =&gt; &#39;0644&#39;,
    }
    package { &#39;haproxy&#39;:
        ensure =&gt; installed,
        before =&gt; File[&#39;haproxy.cfg&#39;],
    }
    service { &#39;haproxy&#39;:
        ensure    =&gt; running,
        subscribe =&gt; File[&#39;haproxy.cfg&#39;],
    }
}
</span><span style="color:#b48ead;">EOF
</span></code></pre>
<p>We can set up the container to bind to our host ports 80 and 443.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">cat </span><span style="color:#c0c5ce;">&lt;&lt;</span><span style="color:#b48ead;">EOF </span><span style="color:#c0c5ce;">&gt; /config/nspawn/web.nspawn</span><span style="color:#a3be8c;">
[Network]
Port=80
Port=443
</span><span style="color:#b48ead;">EOF
</span></code></pre>
<p>Then add in our firewall rules to the <code>/etc/iptables/iptables.rules</code> file, and reboot <code>iptables</code>.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;"> # Allow SSH connections.
 --append TCP --protocol tcp --dport 22 --jump ACCEPT
 # Allow HTTP connections.
</span><span style="color:#a3be8c;">+--append TCP --protocol tcp --dport 80 --jump ACCEPT
</span><span style="color:#c0c5ce;"> # Allow HTTPS connections.
</span><span style="color:#a3be8c;">+--append TCP --protocol tcp --dport 443 --jump ACCEPT

</span></code></pre>
<p>Finally we can create the machine:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">machinectl</span><span style="color:#c0c5ce;"> clone base web
</span><span style="color:#bf616a;">machinectl</span><span style="color:#c0c5ce;"> start web
</span></code></pre>
<p>Give it a few seconds then try running <code>systemctl status haproxy -M web</code>.</p>
<p><strong>Gotcha:</strong> Sometimes <code>puppet</code> doesn't wait for the name resolution to configure and needs to be restarted with <code>systemctl restart puppet -M web</code>. I'm currently pondering solutions to this.</p>
<figure class="enriched ">
        <figcaption>That looks great.</figcaption>
        <img srcset="
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;17fa2bab2e0df7b400.jpg 1920w,
              https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;b7c1d6feae84cdf800.jpg 3840w
              "
              sizes="
                     (max-width: 1200px) 1200px,
                     (max-width: 1800px) 1800px,
                     3840px"
              src="https:&#x2F;&#x2F;hoverbear.org&#x2F;processed_images&#x2F;e4a3bb81ac2d847400.jpg"
              alt="That looks great." />
    </figure>
<h2 id="rest-and-test">Rest and Test</h2>
<p>Since the hostname is <code>silicon.hoverbear.org</code> is already mapped in DNS for me, I'll use that for testing. You want to make your container <code>web-$SUBDOMAIN</code>.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">machinectl</span><span style="color:#c0c5ce;"> clone base web-silicon
</span><span style="color:#bf616a;">machinectl</span><span style="color:#c0c5ce;"> start web-silicon
</span></code></pre>
<p>Since we're testing we don't need to be clean at all. Just shell in, <code>pacman -Syu nginx openssl</code> and edit the <code>/etc/nginx/nginx.conf</code> on that container according to this diff:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">-listen       80;
</span><span style="color:#a3be8c;">+listen       [::]:443 ssl;
+ssl_certificate /etc/nginx/ssl/nginx.crt;
+ssl_certificate_key /etc/nginx/ssl/nginx.key;
</span></code></pre>
<p>Then generate the certificate with:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#bf616a;">mkdir -p</span><span style="color:#c0c5ce;"> /etc/nginx/ssl
</span><span style="color:#bf616a;">openssl</span><span style="color:#c0c5ce;"> req</span><span style="color:#bf616a;"> -x509 -nodes -days</span><span style="color:#c0c5ce;"> 365</span><span style="color:#bf616a;"> -newkey</span><span style="color:#c0c5ce;"> rsa:2048</span><span style="color:#bf616a;"> -keyout</span><span style="color:#c0c5ce;"> /etc/nginx/ssl/nginx.key</span><span style="color:#bf616a;"> -out</span><span style="color:#c0c5ce;"> /etc/nginx/ssl/nginx.crt
</span></code></pre>
<p>Then start up the <code>nginx</code> service on that container. Verify you can <code>curl web-silicon</code> from both the container itself and your <code>web</code> container. You can check <code>systemctl status -M web-silicon nginx</code> and <code>systemctl status -M web haproxy</code> for any messages.</p>
<p>With any luck, you'll see the <code>nginx</code> default web page.</p>
<p>If all is good you can make these machines default to running with <code>machinectl enable web puppet</code>. In our next post we'll get around to setting more refined web service. Remember, <code>web-silicon</code> was just a hello world.</p>
<h2 id="system-evolution">System Evolution</h2>
<p>Over time our system will inevitably change, grow, and decay. We've been spending time to make sure that whatever happens we'll have the tools to keep going. We haven't gone out of our way to over-engineer anything so far, we've just made what we need with a few sharp tools.</p>
<p>As we keep moving ahead we'll discover more needs and eventually build up our services to be better and stronger as a whole, but for now we have the basis to start our work. <code>nspawn</code> containers are persistent, but we can remove them whenever we want and re-create them with a new configuration. Our Puppet master will re-configure new images the same as old ones, and what we extend out with that can be retroactively applied to all. The key is for us to maintain a persisting copy of the data necessary in a safe space. BTRFS and the <code>Bind=</code> option of <code>nspawn</code> enable this.</p>
<p>In our next post we'll explore how to deploy a basic folder based <code>nginx</code> host and <a href="https://github.com/RustFestEU/call4papers">the RustFestEU Call for Papers</a> site. Then, it'll go live! Whoa! But first, let's take a break. That post was <strong>so</strong> long!</p>


            </article>
        </main>
        
        <footer class="post-footer">
    <div class="content">
        <h4><a href=/>← Back to top of index</a></h4>
    
        <h4>By Ana Hobden</h4><p>
            Connect through&nbsp;<a href="https://github.com/hoverbear">@hoverbear</a> on Github,&nbsp;<a href="https://twitter.com/a_hoverbear">@a_hoverbear</a> on Twitter,</a>&nbsp;
            or track via <a class="subscribe" href="https:&#x2F;&#x2F;hoverbear.org/rss.xml">RSS Feed</a>.
        </p><p>Built from <a href="https://github.com/Hoverbear/hoverbear.org/commit/e2659fe1ed372b762e64a5f21a189f57c7414a73
"><code>e2659fe1ed372b762e64a5f21a189f57c7414a73
</code></a></p>
    </div>
</footer>
            
    </body>

</html>
