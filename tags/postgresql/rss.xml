<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Hoverbear - PostgreSQL</title>
        <link>https://hoverbear.org</link>
        <description>A computer scientist working in open source towards a more hopeful future.</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://hoverbear.org/tags/postgresql/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 09 Feb 2022 00:00:00 +0000</lastBuildDate>
        <item>
            <title>PostgreSQL Aggregates with Rust</title>
            <pubDate>Wed, 09 Feb 2022 00:00:00 +0000</pubDate>
            <link>https://hoverbear.org/blog/postgresql-aggregates-with-rust/</link>
            <guid>https://hoverbear.org/blog/postgresql-aggregates-with-rust/</guid>
            <description>&lt;p&gt;Reaching for something like &lt;code&gt;SUM(vals)&lt;&#x2F;code&gt; or &lt;code&gt;AVG(vals)&lt;&#x2F;code&gt; is a common habit when using PostgreSQL. These &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.postgresql.org&#x2F;docs&#x2F;current&#x2F;functions-aggregate.html&quot;&gt;aggregate functions&lt;&#x2F;a&gt; offer users an easy, efficient way to compute results from a set of inputs.&lt;&#x2F;p&gt;
&lt;p&gt;How do they work? What makes them different than a function? How do we make one? What kinds of other uses exist?&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll explore creating some basic ones using SQL, then create an extension that defines aggregates in Rust using &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;zombodb&#x2F;pgx&quot;&gt;&lt;code&gt;pgx&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; 0.3.0&#x27;s new aggregate support.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Forging SQL from Rust</title>
            <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
            <link>https://hoverbear.org/blog/forging-sql-from-rust/</link>
            <guid>https://hoverbear.org/blog/forging-sql-from-rust/</guid>
            <description>&lt;p&gt;PostgreSQL offers an extension interface, and it&#x27;s my belief that Rust is a fantastic language to write extensions for it. &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;zombodb&quot;&gt;Eric Ridge&lt;&#x2F;a&gt; thought so too, and started &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;zombodb&#x2F;pgx&quot;&gt;&lt;code&gt;pgx&lt;&#x2F;code&gt;&lt;&#x2F;a&gt; awhile back. I&#x27;ve been working with him to improve the toolkit, and wanted to share about one of our latest hacks: improving the generation of extension SQL code to interface with Rust.&lt;&#x2F;p&gt;
&lt;p&gt;This post is more on the advanced side, as it assumes knowledge of both Rust and PostgreSQL. We&#x27;ll approach topics like foreign functions, dynamic linking, procedural macros, and linkers.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Hierarchical Structures in PostgreSQL</title>
            <pubDate>Sun, 19 Jan 2020 00:00:00 +0000</pubDate>
            <link>https://hoverbear.org/blog/postgresql-hierarchical-structures/</link>
            <guid>https://hoverbear.org/blog/postgresql-hierarchical-structures/</guid>
            <description>&lt;p&gt;It&#x27;s a common pattern: a database developer at a startup is probably on the Product subteam of the Engineering team at their company. In a department store, shoes are a subcategory of clothing, while your favorite thermos is probably in the travel department.&lt;&#x2F;p&gt;
&lt;p&gt;In any Github organization, there are teams within teams within teams. In any large department store there are categories deeply nested. In any recipe book, there are many ways to classify food.&lt;&#x2F;p&gt;
&lt;p&gt;So how can we model them?&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
